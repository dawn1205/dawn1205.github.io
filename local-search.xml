<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>学习Gremlin</title>
    <link href="undefined2019/12/09/%E5%AD%A6%E4%B9%A0Gremlin/"/>
    <url>2019/12/09/%E5%AD%A6%E4%B9%A0Gremlin/</url>
    
    <content type="html"><![CDATA[<h1 id="学习Gremlin"><a href="#学习Gremlin" class="headerlink" title="学习Gremlin"></a>学习Gremlin</h1><table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td>版本号</td><td>v.0.0.1</td></tr><tr><td>更新日期</td><td>2019年12月9日</td></tr><tr><td>作者</td><td>刘鑫</td></tr></tbody></table><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>随着社交、电商、金融、零售、物联网等行业的快速发展，现实社会织起了了一张庞大而复杂的关系网，<strong>传统数据库很难处理关系运算</strong>。</p><p>大数据行业需要处理的数据之间的关系随数据量呈几何级数增长，亟需一种支持海量复杂数据关系运算的数据库，图数据库应运而生。</p><h3 id="1-1、什么是图数据库"><a href="#1-1、什么是图数据库" class="headerlink" title="1.1、什么是图数据库"></a>1.1、什么是图数据库</h3><h4 id="1-1-1、什么视图"><a href="#1-1-1、什么视图" class="headerlink" title="1.1.1、什么视图"></a>1.1.1、什么视图</h4><p>图由两个元素组成：<strong>节点</strong>和<strong>关系</strong>。</p><p>每个节点代表一个实体（人，地，事物，类别或其他数据），每个关系代表两个节点的关联方式。这种通用结构可以对各种场景进行建模 - 从道路系统到设备网络，到人口的病史或由关系定义的任何其他事物。</p><h4 id="1-1-2、什么是图数据库"><a href="#1-1-2、什么是图数据库" class="headerlink" title="1.1.2、什么是图数据库"></a>1.1.2、什么是图数据库</h4><p><strong>图数据库(Graph database)</strong>并非指存储图片的数据库，而是以<strong>图</strong>这种数据结构存储和查询数据。</p><p><strong>图形数据库</strong>是一种在线数据库管理系统，具有处理图形数据模型的创建，读取，更新和删除（CRUD）操作。</p><p>与其他数据库不同，<strong>关系</strong>在图数据库中占首要地位。这意味着应用程序不必使用外键或带外处理（如MapReduce）来推断数据连接。</p><p>与关系数据库或其他NoSQL数据库相比，图数据库的数据模型也更加简单，更具表现力。</p><p>图形数据库是为与事务（OLTP）系统一起使用而构建的，并且在设计时考虑了事务完整性和操作可用性。</p><h4 id="1-1-3、两个重要属性"><a href="#1-1-3、两个重要属性" class="headerlink" title="1.1.3、两个重要属性"></a>1.1.3、两个重要属性</h4><p>根据存储和处理模型不同，市面上图数据库也有一些区分。比如：</p><p><strong>Neo4J</strong>就是属于原生图数据库，它使用的后端存储是专门为Neo4J这种图数据库定制和优化的，理论上说能更有利于发挥图数据库的性能。</p><p>而<strong>JanusGraph</strong>不是原生图数据库，而将数据存储在其他系统上，比如Hbase。</p><h5 id="1-1-3-1、图存储"><a href="#1-1-3-1、图存储" class="headerlink" title="1.1.3.1、图存储"></a>1.1.3.1、图存储</h5><p>一些图数据库使用<strong>原生图存储</strong>，这类存储是经过优化的，并且是专门为了存储和管理图而设计的。并不是所有图数据库都是使用原生图存储，也有一些图数据库将图数据序列化，然后保存到关系型数据库或者面向对象数据库，或其他通用数据存储中。</p><h5 id="1-1-3-2、图处理引擎"><a href="#1-1-3-2、图处理引擎" class="headerlink" title="1.1.3.2、图处理引擎"></a>1.1.3.2、图处理引擎</h5><p>原生图处理（也称为<strong>无索引邻接</strong>）是处理图数据的最有效方法，因为连接的节点在数据库中物理地指向彼此。非本机图处理使用其他方法来处理CRUD操作。</p><h3 id="1-2、对比"><a href="#1-2、对比" class="headerlink" title="1.2、对比"></a>1.2、对比</h3><h4 id="1-2-1、与NoSQL数据对比"><a href="#1-2-1、与NoSQL数据对比" class="headerlink" title="1.2.1、与NoSQL数据对比"></a>1.2.1、与NoSQL数据对比</h4><table><thead><tr><th align="left">分类</th><th align="left">数据模型</th><th>优势</th><th align="left">劣势</th><th>举例</th></tr></thead><tbody><tr><td align="left">键值数据库</td><td align="left">哈希表</td><td>查找速度快</td><td align="left">数据无结构化，通常只被当作字符串或者二进制数据</td><td>Redis</td></tr><tr><td align="left">列存储数据库</td><td align="left">列式数据存储</td><td>查找速度快；<br />支持分布横向扩展；<br />数据压缩率高</td><td align="left">功能相对受限</td><td>HBase</td></tr><tr><td align="left">文档型数据库</td><td align="left">键值对扩展</td><td>数据结构要求不严格；<br />表结构可变；<br />不需要预先定义表结构</td><td align="left">查询性能不高，缺乏统一的查询语法</td><td>MongoDB</td></tr><tr><td align="left">图数据库</td><td align="left">节点和关系组成的图</td><td>利用图结构相关算法(最短路径、节点度关系查找等)</td><td align="left">可能需要对整个图做计算，不利于图数据分布存储</td><td>Neo4j、JanusGraph</td></tr></tbody></table><h4 id="1-2-2、与关系型数据库对比"><a href="#1-2-2、与关系型数据库对比" class="headerlink" title="1.2.2、与关系型数据库对比"></a>1.2.2、与关系型数据库对比</h4><p>关系型数据库实际上是不擅长处理关系的。很多场景下，你的业务需求完全超出了当前的数据库架构。</p><p>当我们要查询：“用户购买了那些商品？” 或者 “该商品有哪些客户购买过？” 需要开发人员JOIN几张表，效率非常低下。</p><p>而“购买该产品的客户还购买了哪些商品？”类似的查询几乎不可能实现。</p><p>试图在一个社交网络里找到最大深度为5的朋友的朋友。他们的数据集包括100万人，每人约有50个朋友。实验结果如下：</p><table><thead><tr><th>深度</th><th>MySQL执行时间(S)</th><th>Neo4J执行时间(S)</th><th>返回记录数</th></tr></thead><tbody><tr><td>2</td><td>0.016</td><td>0.01</td><td>~2500</td></tr><tr><td>3</td><td>30.267</td><td>0.168</td><td>~110  000</td></tr><tr><td>4</td><td>1543.505</td><td>1.359</td><td>~600  000</td></tr><tr><td>5</td><td>未完成</td><td>2.132</td><td>~800  000</td></tr></tbody></table><h3 id="1-3、-Neo4J和JanusGraph"><a href="#1-3、-Neo4J和JanusGraph" class="headerlink" title="1.3、 Neo4J和JanusGraph"></a>1.3、 Neo4J和JanusGraph</h3><h4 id="1-3-1、Neo4J"><a href="#1-3-1、Neo4J" class="headerlink" title="1.3.1、Neo4J"></a>1.3.1、Neo4J</h4><p>Neo4J是由Java实现的开源图数据库。自2003年开始开发，直到2007年正式发布第一版，并托管于GitHub上。</p><p>目前Neo4J分为社区版和企业版，社区版只支持单机部署，功能受限。企业版支持主从复制和读写分离，包含可视化管理工具。</p><h4 id="1-3-2、JanusGraph"><a href="#1-3-2、JanusGraph" class="headerlink" title="1.3.2、JanusGraph"></a>1.3.2、JanusGraph</h4><p>JanusGraph是一个Linux基金会下的开源分布式图数据库。</p><p>JanusGraph支持多种储存后端（包括Apache Cassandra、Apache HBase、Bigtable、Berkeley DB）。JanusGraph的可扩展性取决于与JanusGraph一起使用的基础技术。例如，通过使用Apache Cassandra作为存储后端，可以将JanusGraph简单地扩展到多个数据中心。</p><p>JanusGraph通过与大数据平台（Apache Spark，Apache Giraph，Apache Hadoop）集成，支持全局图数据的分析、报告和ETL。</p><p>JanusGraph通过外部索引存储（Elasticsearch，Solr，Lucene）支持地理、数字范围和全文搜索。</p><h3 id="1-4、Cypher图查询语言-和-Gremlin查询语言"><a href="#1-4、Cypher图查询语言-和-Gremlin查询语言" class="headerlink" title="1.4、Cypher图查询语言 和 Gremlin查询语言"></a>1.4、Cypher图查询语言 和 Gremlin查询语言</h3><p>Cypher是Neo4j的图形查询语言，允许用户存储和检索图形数据库中的数据。</p><p>Gremlin语言是图数据库查询语言，相当于SQL之于关系型数据库。</p><h2 id="2-图基本概念与操作"><a href="#2-图基本概念与操作" class="headerlink" title="2.图基本概念与操作"></a>2.图基本概念与操作</h2><p>Gremlin语言是图数据库查询语言，相当于SQL之于关系型数据库。</p><h3 id="2-1、图剧本概念"><a href="#2-1、图剧本概念" class="headerlink" title="2.1、图剧本概念"></a>2.1、图剧本概念</h3><ul><li><p>图Graph：指关系图。比如：同学及朋友关系图、银行转账图等。</p></li><li><p>顶点Vertex：一般指实体。比如：人、账户等。</p></li><li><p>边Edge：一般指关系。比如：朋友关系、转账动作等。</p></li><li><p>属性Property：顶点或边可以包含属性，比如：人的姓名、人的年龄、转账的时间。</p><p><img src="1.png" srcset="/img/loading.gif" alt=""></p></li></ul><h3 id="2-2、图的基本操作"><a href="#2-2、图的基本操作" class="headerlink" title="2.2、图的基本操作"></a>2.2、图的基本操作</h3><ul><li>V()：查询顶点，一般作为图查询的第1步。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询图中所有的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：g 代表的是整个图</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一切查询都是以图开始</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据id查询顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'4:Gremlin'</span>, <span class="string">'3:TinkerPop'</span>)</span></pre></td></tr></table></figure><ul><li>E()：查询边，一般作为图查询的第1步。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询图中所有的边</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.E()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据id查询边</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.E(<span class="string">'S3:TinkerPop&gt;4&gt;&gt;S4:Gremlin'</span>)</span></pre></td></tr></table></figure><ul><li>id()：获取顶点、边的id。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有顶点的id</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().id()</span></pre></td></tr></table></figure><blockquote><p>类似的，通过<code>g.E().id()</code>查询所有边的id。<br>注意：Gremlin Step是作用在上一步产生的结果集上，如果上一步的结果是多个元素，那么这里<code>id()</code>将返回多个元素的id</p></blockquote><ul><li>label()：获取顶点、边的label。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有顶点的label</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().label()</span></pre></td></tr></table></figure><blockquote><p>类似的，通过g.E().label()查询所有边的label。</p></blockquote><ul><li>properties()：获取顶点、边的属性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">g.V().properties()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有顶点的“lang”属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果无“lang”属性的顶点将跳过</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V().properties(<span class="string">'lang'</span>)</span></pre></td></tr></table></figure><blockquote><p>类似的，通过g.E().properties()查询所有边的属性。</p></blockquote><p>此外 properties()还可以和 key()、value()搭配使用，以获取属性的名称或值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有顶点的属性名称</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().properties().key()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有顶点的属性值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().properties().value()</span></pre></td></tr></table></figure><ul><li>valueMap()：获取顶点、边的属性， valueMap()与 properties()不同的地方是：它们返回的结构不一样，后者将所有的属性扁平化到一个大列表里面，一个元素代表一个属性；前者保持一个顶点或一条边的属性作为一组，每一组由若干属性的键值对组成。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有顶点的属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().valueMap()</span></pre></td></tr></table></figure><blockquote><p>类似的，通过g.E().valueMap()查询所有边的属性。</p></blockquote><ul><li>values()：获取顶点、边的属性值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有顶点的属性值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 效果等同于：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// g.V().properties().value()</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V().values()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有顶点的“lang”属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 效果等同于：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// g.V().properties('lang').value()</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V().values(<span class="string">'lang'</span>)</span></pre></td></tr></table></figure><blockquote><p>类似的，通过g.E().values()查询所有边的属性值。</p></blockquote><h2 id="3-边的遍历操作"><a href="#3-边的遍历操作" class="headerlink" title="3.边的遍历操作"></a>3.边的遍历操作</h2><h3 id="3-1、边遍历概念"><a href="#3-1、边遍历概念" class="headerlink" title="3.1、边遍历概念"></a>3.1、边遍历概念</h3><p>边遍历是指通过顶点来访问与其有关联边的邻接顶点（或者仅访问邻接边），边遍历是图数据库与图计算的核心。</p><p><img src="2.png" srcset="/img/loading.gif" alt=""></p><h4 id="3-1-1、顶点为基准"><a href="#3-1-1、顶点为基准" class="headerlink" title="3.1.1、顶点为基准"></a>3.1.1、顶点为基准</h4><ul><li>out(label): 根据指定的EdgeLabel来访问顶点的OUT方向邻接点（可以是零个EdgeLabel，代表所有类型边；也可以一个或多个EdgeLabel，代表任意给定EdgeLabel的边，下同）</li><li>in(label): 根据指定的EdgeLabel来访问顶点的IN方向邻接点</li><li>both(label): 根据指定的EdgeLabel来访问顶点的双向邻接点</li><li>outE(label): 根据指定的EdgeLabel来访问顶点的OUT方向邻接边</li><li>inE(label): 根据指定的EdgeLabel来访问顶点的IN方向邻接边</li><li>bothE(label): 根据指定的EdgeLabel来访问顶点的双向邻接边</li></ul><h4 id="3-1-2、边为基准"><a href="#3-1-2、边为基准" class="headerlink" title="3.1.2、边为基准"></a>3.1.2、边为基准</h4><ul><li>outV(): 访问边的出顶点（注意：这里是以边为基准，上述Step均以顶点为基准），出顶点是指边的起始顶点</li><li>inV(): 访问边的入顶点，入顶点是指边的目标顶点，也就是箭头指向的顶点</li><li>bothV(): 访问边的双向顶点</li><li>otherV(): 访问边的伙伴顶点，即相对于基准顶点而言的另一端的顶点</li></ul><h3 id="3-2、实例讲解"><a href="#3-2、实例讲解" class="headerlink" title="3.2、实例讲解"></a>3.2、实例讲解</h3><ul><li>out()：访问顶点的OUT方向邻接点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先查询图中所有的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 然后访问顶点的OUT方向邻接点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：out()的基准必须是顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V().out()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问某个顶点的OUT方向邻接点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意'3:TinkerPop'是顶点的id</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该id是插入顶点时自动生成的</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:TinkerPop'</span>).out()</span></pre></td></tr></table></figure><blockquote><p>目前讲解过的Gremlin Steps中，顶点的id可通过g.V()来获取，也可通过即将讲解的has()来获取（根据属性查询顶点）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问某个顶点的OUT方向邻接点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 且限制仅“define”类型的边相连的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:TinkerPop'</span>).out(<span class="string">'define'</span>)</span></pre></td></tr></table></figure><ul><li>in()：访问顶点的IN方向邻接点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问某个顶点的IN方向邻接点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:TinkerPop'</span>).in()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问某个顶点的IN方向邻接点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 且限制了关联边的类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:TinkerPop'</span>).in(<span class="string">'implements'</span>)</span></pre></td></tr></table></figure><ul><li>both()：访问顶点的双向邻接点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问某个顶点的双向邻接点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:TinkerPop'</span>).both()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问某个顶点的双向邻接点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 且限制了关联边的类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:TinkerPop'</span>).both(<span class="string">'implements'</span>, <span class="string">'define'</span>)</span></pre></td></tr></table></figure><ul><li>outE(): 访问顶点的OUT方向邻接边</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问某个顶点的OUT方向邻接边</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:TinkerPop'</span>).outE()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问某个顶点的OUT方向邻接边</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 且限制了关联边的类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:TinkerPop'</span>).outE(<span class="string">'define'</span>)</span></pre></td></tr></table></figure><ul><li>inE(): 访问顶点的IN方向邻接边</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问某个顶点的IN方向邻接边</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:TinkerPop'</span>).inE()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问某个顶点的IN方向邻接边</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 且限制了关联边的类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:TinkerPop'</span>).inE(<span class="string">'implements'</span>)</span></pre></td></tr></table></figure><ul><li>bothE(): 访问顶点的双向邻接边</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问某个顶点的双向邻接边</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:TinkerPop'</span>).bothE()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问某个顶点的双向邻接边</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 且限制了关联边的类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:TinkerPop'</span>).bothE(<span class="string">'define'</span>, <span class="string">'implements'</span>)</span></pre></td></tr></table></figure><ul><li>outV(): 访问边的出顶点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问某个顶点的IN邻接边</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 然后获取边的出顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:TinkerPop'</span>).inE().outV()</span></pre></td></tr></table></figure><blockquote><p>一般情况下，inE().outV()等价于in()</p></blockquote><ul><li>inV(): 访问边的入顶点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问某个顶点的OUT邻接边</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 然后获取边的入顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:TinkerPop'</span>).outE().inV()</span></pre></td></tr></table></figure><blockquote><p>一般情况下，outE().inV()等价于out()</p></blockquote><ul><li>bothV(): 访问边的双向顶点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问某个顶点的OUT邻接边</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 然后获取边的双向顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:TinkerPop'</span>).outE().bothV()</span></pre></td></tr></table></figure><blockquote><p>注意：bothV()会把源顶点也一起返回，因此只要源顶点有多少条出边，结果集中就会出现多少次源顶点</p></blockquote><ul><li>otherV() : 访问边的伙伴顶点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问某个顶点的OUT邻接边</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 然后获取边的伙伴顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:TinkerPop'</span>).outE().otherV()</span></pre></td></tr></table></figure><blockquote><p>一般情况下，outE().otherV()等价于out()，inE().otherV()等价于in()</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问某个顶点的双向邻接边</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 然后获取边的伙伴顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:TinkerPop'</span>).bothE().otherV()</span></pre></td></tr></table></figure><blockquote><p>一般情况下，bothE().otherV()等价于both()</p></blockquote><h3 id="3-3、综合运用"><a href="#3-3、综合运用" class="headerlink" title="3.3、综合运用"></a>3.3、综合运用</h3><ul><li>多度查询</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4度out()查询</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过id找到“javeme”作者顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过out()访问其创建的软件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继续通过out()访问软件实现的框架</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继续通过out()访问框架包含的软件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继续通过out()访问软件支持的语言</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'javeme'</span>).out(<span class="string">'created'</span>).out(<span class="string">'implements'</span>).out(<span class="string">'contains'</span>).out(<span class="string">'supports'</span>)</span></pre></td></tr></table></figure><ul><li>查询支持Gremlin语言的软件的作者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过id找到“Gremlin”语言顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过in()访问支持Gremlin的软件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继续通过in()访问软件的作者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'4:Gremlin'</span>).in(<span class="string">'supports'</span>).in(<span class="string">'created'</span>)</span></pre></td></tr></table></figure><ul><li>查询某个作者的共同作者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过id找到“javeme”作者顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过out()访问其创建的软件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过in()访问软件的所有作者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'javeme'</span>).out(<span class="string">'created'</span>).in(<span class="string">'created'</span>)</span></pre></td></tr></table></figure><h2 id="4-Has条件过滤"><a href="#4-Has条件过滤" class="headerlink" title="4.Has条件过滤"></a>4.Has条件过滤</h2><h3 id="4-1、说明"><a href="#4-1、说明" class="headerlink" title="4.1、说明"></a>4.1、说明</h3><p>在众多Gremlin的语句中，有一大类是filter类型，顾名思义，就是对输入的对象进行条件判断，只有满足过滤条件的对象才可以通过filter进入下一步。</p><p>has语句是filter类型语句的代表，能够以顶点和边的属性作为过滤条件，决定哪些对象可以通过。has语句包括很多变种：</p><ul><li>hasLabel(labels…): object的label与labels列表中任何一个匹配就可以通过</li><li>hasId(ids…): object的id满足ids列表中的任何一个就可以通过</li><li>has(key, value): 包含属性“key=value”的object通过，作用于顶点或者边</li><li>has(label, key, value): 包含属性“key=value”且label值匹配的object通过，作用于顶点或者边</li><li>has(key, predicate): 包含键为key且对应的value满足predicate的object通过，作用于顶点或者边</li><li>hasKey(keys…): object的属性键包含所有的keys列表成员才能通过，作用于顶点属性</li><li>hasValue(values…): object的属性值包含所有的values列表成员才能通过，作用于顶点属性</li><li>has(key): 包含键为key的属性的object通过，作用于顶点或者边</li><li>hasNot(key): 不包含键为key的属性的object通过，作用于顶点或者边</li></ul><h3 id="4-2、实例讲解"><a href="#4-2、实例讲解" class="headerlink" title="4.2、实例讲解"></a>4.2、实例讲解</h3><p> 在JanusGraph中，按property的值查询之前，应该对property建立索引，否则将无法查到结果并引发异常。 </p><h4 id="4-2-1、hasLabel-label-，通过label来过滤顶点或边，满足label列表中一个即可通过"><a href="#4-2-1、hasLabel-label-，通过label来过滤顶点或边，满足label列表中一个即可通过" class="headerlink" title="4.2.1、hasLabel(label...)，通过label来过滤顶点或边，满足label列表中一个即可通过"></a>4.2.1、<code>hasLabel(label...)</code>，通过label来过滤顶点或边，满足label列表中一个即可通过</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询label为"person"的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>)</span></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询label为"person"或者"software"的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>, <span class="string">'software'</span>)</span></pre></td></tr></table></figure><h4 id="4-2-2、hasId-ids…-，通过id来过滤顶点或者边，满足id列表中的一个即可通过"><a href="#4-2-2、hasId-ids…-，通过id来过滤顶点或者边，满足id列表中的一个即可通过" class="headerlink" title="4.2.2、hasId(ids…)，通过id来过滤顶点或者边，满足id列表中的一个即可通过"></a>4.2.2、<code>hasId(ids…)</code>，通过id来过滤顶点或者边，满足id列表中的一个即可通过</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询id为"zhoney"的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasId(<span class="string">'zhoney'</span>)</span></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询id为“zhoney”或者“3:HugeGraph”的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasId(<span class="string">'zhoney'</span>, <span class="string">'3:HugeGraph'</span>)</span></pre></td></tr></table></figure><h4 id="4-2-3、has-key-value-，通过属性的名字和值来过滤顶点或边"><a href="#4-2-3、has-key-value-，通过属性的名字和值来过滤顶点或边" class="headerlink" title="4.2.3、has(key, value)，通过属性的名字和值来过滤顶点或边"></a>4.2.3、<code>has(key, value)</code>，通过属性的名字和值来过滤顶点或边</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询“addr”属性值为“Beijing”的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().has(<span class="string">'addr'</span>, <span class="string">'Beijing'</span>)</span></pre></td></tr></table></figure><h4 id="4-2-4、has-label-key-value-，通过label和属性的名字和值过滤顶点和边"><a href="#4-2-4、has-label-key-value-，通过label和属性的名字和值过滤顶点和边" class="headerlink" title="4.2.4、has(label, key, value)，通过label和属性的名字和值过滤顶点和边"></a>4.2.4、<code>has(label, key, value)</code>，通过label和属性的名字和值过滤顶点和边</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询label为“person”且“addr”属性值为“Beijing”的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().has(<span class="string">'person'</span>, <span class="string">'addr'</span>, <span class="string">'Beijing'</span>)</span></pre></td></tr></table></figure><h4 id="4-2-5、has-key-predicate-，通过对指定属性用条件过滤顶点和边"><a href="#4-2-5、has-key-predicate-，通过对指定属性用条件过滤顶点和边" class="headerlink" title="4.2.5、has(key, predicate)，通过对指定属性用条件过滤顶点和边"></a>4.2.5、<code>has(key, predicate)</code>，通过对指定属性用条件过滤顶点和边</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询“addr”属性值为“Beijing”的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().has(<span class="string">'age'</span>, gt(<span class="number">20</span>))</span></pre></td></tr></table></figure><h4 id="4-2-6、hasKey-keys…-properties包含所有的key才能通过"><a href="#4-2-6、hasKey-keys…-properties包含所有的key才能通过" class="headerlink" title="4.2.6、hasKey(keys…): properties包含所有的key才能通过"></a>4.2.6、<code>hasKey(keys…)</code>: properties包含所有的key才能通过</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询包含属性“lang”的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().properties().hasKey(<span class="string">'lang'</span>)</span></pre></td></tr></table></figure><h6 id="特殊用法：直接将hasKey-作用于顶点，仅后端是Cassandra时支持"><a href="#特殊用法：直接将hasKey-作用于顶点，仅后端是Cassandra时支持" class="headerlink" title="特殊用法：直接将hasKey()作用于顶点，仅后端是Cassandra时支持"></a>特殊用法：直接将<code>hasKey()</code>作用于顶点，仅后端是<code>Cassandra</code>时支持</h6><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询包含属性“age”的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasKey(<span class="string">'age'</span>)</span></pre></td></tr></table></figure><h4 id="4-2-7、hasValue-values…-properties包含所有的value才能通过"><a href="#4-2-7、hasValue-values…-properties包含所有的value才能通过" class="headerlink" title="4.2.7、hasValue(values…): properties包含所有的value才能通过"></a>4.2.7、<code>hasValue(values…)</code>: properties包含所有的value才能通过</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询包含属性值“Beijing”的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().properties().hasValue(<span class="string">'Beijing'</span>)</span></pre></td></tr></table></figure><h6 id="特殊用法：直接将hasValue-作用于顶点，仅后端是Cassandra时支持"><a href="#特殊用法：直接将hasValue-作用于顶点，仅后端是Cassandra时支持" class="headerlink" title="特殊用法：直接将hasValue()作用于顶点，仅后端是Cassandra时支持"></a>特殊用法：直接将<code>hasValue()</code>作用于顶点，仅后端是<code>Cassandra</code>时支持</h6><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询包含属性值“Beijing”的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasValue(<span class="string">'Beijing'</span>)</span></pre></td></tr></table></figure><h4 id="4-2-8、has-key-有这个属性的通过"><a href="#4-2-8、has-key-有这个属性的通过" class="headerlink" title="4.2.8、has(key): 有这个属性的通过"></a>4.2.8、<code>has(key)</code>: 有这个属性的通过</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询包含属性“age”的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().has(<span class="string">'age'</span>)</span></pre></td></tr></table></figure><h4 id="4-2-9、hasNot-key-没有这个属性的通过"><a href="#4-2-9、hasNot-key-没有这个属性的通过" class="headerlink" title="4.2.9、hasNot(key): 没有这个属性的通过"></a>4.2.9、<code>hasNot(key)</code>: 没有这个属性的通过</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询没有属性“age”的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasNot(<span class="string">'age'</span>)</span></pre></td></tr></table></figure><h2 id="5-图查询返回结果数限制"><a href="#5-图查询返回结果数限制" class="headerlink" title="5.图查询返回结果数限制"></a>5.图查询返回结果数限制</h2><h3 id="5-1、说明"><a href="#5-1、说明" class="headerlink" title="5.1、说明"></a>5.1、说明</h3><p><img src="C:%5CUsers%5CLiux-Pc%5CDesktop%5C%E5%AD%A6%E4%B9%A0Gremlin%5C3.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>Gremlin能统计查询结果集中元素的个数，且允许从结果集中做范围截取。假设某个查询操作（如：<code>g.V()</code>）的结果集包含8个元素，我们可以从这8个元素中截取指定部分。主要包括： </p></li><li><p>count(): 统计查询结果集中元素的个数；</p></li><li><p>range(m, n): 指定下界和上界的截取，左闭右开。比如range(2, 5)能获取第2个到第4个元素（0作为首个元素，上界为-1时表示剩余全部）；</p></li><li><p>limit(n): 下界固定为0，指定上界的截取，等效于range(0, n)，语义是“获取前n个元素”。比</p></li><li><p>limit(3)能获取前3个元素；</p></li><li><p>tail(n): 上界固定为-1，指定下界的截取，等效于range(count - n, -1)，语义是“获取后n个元素”。比如tail(2)能获取最后的2个元素；</p></li><li><p>skip(n): 上界固定为-1，指定下界的截取，等效于range(n, -1)，语义是“跳过前n个元素，获取剩余的元素”。比如skip(6)能跳过前6个元素，获取最后2个元素。</p></li></ul><h3 id="5-2、实例讲解"><a href="#5-2、实例讲解" class="headerlink" title="5.2、实例讲解"></a>5.2、实例讲解</h3><h4 id="5-2-1、-count-：查询当前traverser中的元素的个数，元素可以是顶点、边、属性、路径等。"><a href="#5-2-1、-count-：查询当前traverser中的元素的个数，元素可以是顶点、边、属性、路径等。" class="headerlink" title="5.2.1、 count()：查询当前traverser中的元素的个数，元素可以是顶点、边、属性、路径等。"></a>5.2.1、 <code>count()</code>：查询当前<code>traverser</code>中的元素的个数，元素可以是顶点、边、属性、路径等。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询图中所有顶点的个数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().count()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询图中类型为“人person”的顶点数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).count()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询图中所有的 “人创建created” 的边数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).outE(<span class="string">'created'</span>).count()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询图中所有顶点的属性数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().properties().count()</span></pre></td></tr></table></figure><h4 id="5-2-2、-range-：限定查询返回的元素的范围，上下界表示元素的偏移量，左闭右开。下界以“0”作为第一个元素，上界为“-1”时表示取到最后的元素。"><a href="#5-2-2、-range-：限定查询返回的元素的范围，上下界表示元素的偏移量，左闭右开。下界以“0”作为第一个元素，上界为“-1”时表示取到最后的元素。" class="headerlink" title="5.2.2、 range()：限定查询返回的元素的范围，上下界表示元素的偏移量，左闭右开。下界以“0”作为第一个元素，上界为“-1”时表示取到最后的元素。"></a>5.2.2、 <code>range()</code>：限定查询返回的元素的范围，上下界表示元素的偏移量，左闭右开。下界以“0”作为第一个元素，上界为“-1”时表示取到最后的元素。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//不加限制地查询所有类型为“人person”的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).range(<span class="number">0</span>, -<span class="number">1</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询类型为“人person”的顶点中的第2个到第5个</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).range(<span class="number">2</span>, <span class="number">5</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询类型为“人person”的顶点中的第5个到最后一个</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).range(<span class="number">5</span>, -<span class="number">1</span>)</span></pre></td></tr></table></figure><h4 id="5-2-3、-limit-：查询前“n”个元素，相当于range-0-n"><a href="#5-2-3、-limit-：查询前“n”个元素，相当于range-0-n" class="headerlink" title="5.2.3、 limit()：查询前“n”个元素，相当于range(0, n)"></a>5.2.3、 <code>limit()</code>：查询前“n”个元素，相当于<code>range(0, n)</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询前两个顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().limit(<span class="number">2</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询前三条边</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.E().limit(<span class="number">3</span>)</span></pre></td></tr></table></figure><h4 id="5-2-4、-tail-：与limit-相反，它查询的是后“n”个元素，相当于range-count-n-1"><a href="#5-2-4、-tail-：与limit-相反，它查询的是后“n”个元素，相当于range-count-n-1" class="headerlink" title="5.2.4、 tail()：与limit()相反，它查询的是后“n”个元素，相当于range(count - n, -1)"></a>5.2.4、 <code>tail()</code>：与<code>limit()</code>相反，它查询的是后“n”个元素，相当于<code>range(count - n, -1)</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询后两个顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().tail(<span class="number">2</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询后三条边</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.E().tail(<span class="number">3</span>)</span></pre></td></tr></table></figure><h4 id="5-2-5、-skip-：跳过前“n”个元素，获取剩余的全部元素"><a href="#5-2-5、-skip-：跳过前“n”个元素，获取剩余的全部元素" class="headerlink" title="5.2.5、 skip()：跳过前“n”个元素，获取剩余的全部元素"></a>5.2.5、 <code>skip()</code>：跳过前“n”个元素，获取剩余的全部元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳过前5个，skip(5)等价于range(5, -1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).skip(<span class="number">5</span>)</span></pre></td></tr></table></figure><h2 id="6-查询路径path"><a href="#6-查询路径path" class="headerlink" title="6.查询路径path"></a>6.查询路径path</h2><h3 id="6-1、说明"><a href="#6-1、说明" class="headerlink" title="6.1、说明"></a>6.1、说明</h3><p>在使用Gremlin对图进行分析时，关注点有时并不仅仅在最终到达的顶点、边或者属性上，通过什么样的路径到达最终的顶点、边和属性同样重要。此时可以借助path()来获取经过的路径信息。</p><p>path()返回当前遍历过的所有路径。有时需要对路径进行过滤，只选择没有环路的路径或者选择包含环路的路径，Gremlin针对这种需求提供了两种过滤路径的step：simplePath()和cyclicPath()。</p><h3 id="6-2、实例讲解"><a href="#6-2、实例讲解" class="headerlink" title="6.2、实例讲解"></a>6.2、实例讲解</h3><h4 id="6-2-1、path-，获取当前遍历过的所有路径"><a href="#6-2-1、path-，获取当前遍历过的所有路径" class="headerlink" title="6.2.1、path()，获取当前遍历过的所有路径"></a>6.2.1、<code>path()</code>，获取当前遍历过的所有路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// “JanusGraph”顶点到与其有直接关联的顶点的路径（仅包含顶点）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'software'</span>).has(<span class="string">'name'</span>,<span class="string">'HugeGraph'</span>).both().path()</span></pre></td></tr></table></figure><p> 如果想要同时获得经过的边的信息，可以用<code>bothE().otherV()</code>替换<code>both()</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// “JanusGraph”顶点到与其有直接关联的顶点的路径（包含顶点和边）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'software'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .has(<span class="string">'name'</span>,<span class="string">'HugeGraph'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .bothE()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .otherV()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .path()</span></pre></td></tr></table></figure><p>输出路径的时候，通过by(property)语句可以指定对象的某个属性代替对象，且连续的多个by()是循环应用到路径中的对象，例如路径中有3个对象[A, B, C]，by(X).by(Y)语句指定两个属性[X Y]，代表用“用A的X属性代表A，用B的Y属性代表B，用C的X属性代表C”，具体可参考如下例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// “HugeGraph”顶点到与其有直接关联的顶点的路径（包含顶点和边）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用“name”属性代表person和software顶点，用“weight”属性代表边</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'software'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .has(<span class="string">'name'</span>,<span class="string">'HugeGraph'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .bothE()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .otherV()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    .path()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    .by(<span class="string">'name'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    .by(<span class="string">'weight'</span>)</span></pre></td></tr></table></figure><p>路径分为两种：有环路径和无环路径。</p><ul><li>有环路径是指路径中至少有一个对象出现的次数大于等于两次。</li><li>无环路径是指路径中所有的对象只出现一次。</li></ul><p><code>path()</code>返回所有路径，包含有环路径和无环路径，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// “HugeGraph”顶点到与其有两层关系的顶点的所有路径（只包含顶点）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'software'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .has(<span class="string">'name'</span>,<span class="string">'HugeGraph'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .both()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .both()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .path()</span></pre></td></tr></table></figure><h4 id="6-2-2、simplePath-，过滤掉路径中含有环路的对象，只保留路径中不含有环路的对象"><a href="#6-2-2、simplePath-，过滤掉路径中含有环路的对象，只保留路径中不含有环路的对象" class="headerlink" title="6.2.2、simplePath()，过滤掉路径中含有环路的对象，只保留路径中不含有环路的对象"></a>6.2.2、<code>simplePath()</code>，过滤掉路径中含有环路的对象，只保留路径中不含有环路的对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// “HugeGraph”顶点到与其有两层关系的顶点的不含环路的路径（只包含顶点）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'software'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .has(<span class="string">'name'</span>,<span class="string">'HugeGraph'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .both()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .both()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .simplePath()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    .path()</span></pre></td></tr></table></figure><h4 id="6-2-3、cyclicPath-，过滤掉路径中不含有环路的对象，只保留路径中含有环路的对象"><a href="#6-2-3、cyclicPath-，过滤掉路径中不含有环路的对象，只保留路径中含有环路的对象" class="headerlink" title="6.2.3、cyclicPath()，过滤掉路径中不含有环路的对象，只保留路径中含有环路的对象"></a>6.2.3、<code>cyclicPath()</code>，过滤掉路径中不含有环路的对象，只保留路径中含有环路的对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// “HugeGraph”顶点到与其有两层关系的顶点的包含环路的路径（只包含顶点）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'software'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .has(<span class="string">'name'</span>,<span class="string">'HugeGraph'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .both()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .both()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .cyclicPath()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    .path()</span></pre></td></tr></table></figure><h2 id="7-循环操作"><a href="#7-循环操作" class="headerlink" title="7.循环操作"></a>7.循环操作</h2><h3 id="7-1、说明"><a href="#7-1、说明" class="headerlink" title="7.1、说明"></a>7.1、说明</h3><p>循环操作是指多次执行某一部分语句，用于语句需要重复运行的场景，比如“查找朋友的朋友的朋友”，可以直接使用循环操作来完成即“查找3层朋友”，下面对具体的循环相关的Step进行说明： </p><ul><li>repeat()<code>: 指定要重复执行的语句，如</code>repeat(out(‘friend’))</li><li>times()<code>: 指定要重复执行的次数，如执行3次</code>repeat(out(‘friend’)).times(3)</li><li>until(): 指定循环终止的条件，如一直找到某个名字的朋友为止</li><li>repeat(out(‘friend’)).until(has(‘name’,’xiaofang’))</li><li>emit(): 指定循环语句的执行过程中收集数据的条件，每一步的结果只要符合条件则被收集，不指定条件时收集所有结果</li><li>loops(): 当前循环的次数，可用于控制最大循环次数等，如最多执行3次</li><li>repeat(out(‘friend’)).until(loops().is(3))</li></ul><h3 id="7-2、实例讲解"><a href="#7-2、实例讲解" class="headerlink" title="7.2、实例讲解"></a>7.2、实例讲解</h3><h4 id="7-2-1、-repeat-times-：按照指定的次数重复执行语句"><a href="#7-2-1、-repeat-times-：按照指定的次数重复执行语句" class="headerlink" title="7.2.1、 repeat() + times()：按照指定的次数重复执行语句"></a>7.2.1、 <code>repeat()</code> + <code>times()</code>：按照指定的次数重复执行语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问某个顶点的OUT邻接点（1次）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意'okram'是顶点的id</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'okram'</span>).repeat(out()).times(<span class="number">1</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问某个顶点的2度双向邻接点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问第1个顶点的所有邻接点（第1层）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 再访问第1层结果顶点的邻接点（第2层）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'okram'</span>).repeat(both()).times(<span class="number">2</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问某个顶点的3度OUT邻接点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问第1个顶点的所有邻接点（第1层）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 再访问第1层结果顶点的邻接点（第2层）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 再访问第2层结果顶点的邻接点（第3层）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'okram'</span>).repeat(out()).times(<span class="number">3</span>)</span></pre></td></tr></table></figure><h4 id="7-2-2、-repeat-until-：根据条件来重复执行语句"><a href="#7-2-2、-repeat-until-：根据条件来重复执行语句" class="headerlink" title="7.2.2、 repeat() + until()：根据条件来重复执行语句"></a>7.2.2、 <code>repeat()</code> + <code>until()</code>：根据条件来重复执行语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询顶点'okram'到顶点'Gremlin'之间的路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环的终止条件是遇到名称是'Gremlin'的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'okram'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .repeat(out())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .until(has(<span class="string">'name'</span>, <span class="string">'Gremlin'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .path()</span></pre></td></tr></table></figure><blockquote><p>注意1：这里用到了path()来获取经过的路径，path的讲解请参考上一期。</p><p>注意2：until()与 times()是互斥的，两个语句无法同时存在于同一个循环中。</p><p>注意3：until()放在repeat()之前或之后的顺序是会影响逻辑的，放前面表示先判断再执行，放后面表示先执行后判断。请对比如下两个语句的执行结果：<br>g.V(‘okram’).repeat(out()).until(hasLabel(‘person’)).path()<br>g.V(‘okram’).until(hasLabel(‘person’)).repeat(out()).path()</p></blockquote><h4 id="7-2-3、-repeat-emit-：收集执行过程中的数据"><a href="#7-2-3、-repeat-emit-：收集执行过程中的数据" class="headerlink" title="7.2.3、 repeat() + emit()：收集执行过程中的数据"></a>7.2.3、 <code>repeat()</code> + <code>emit()</code>：收集执行过程中的数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询顶点'okram'的所有OUT可达点的路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'okram'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">.repeat(out())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .emit()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .path()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询顶点'okram'的所有OUT可达点的路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 且必须满足是'person'类型的点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'okram'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .repeat(out())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .emit(hasLabel(<span class="string">'person'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .path()</span></pre></td></tr></table></figure><blockquote><p>注意：emit()放在repeat()之前或之后的顺序是会影响结果的，放前面表示先收集再执行，放后面表示先执行后收集。请对比如下两个语句的执行结果：<br>g.V(‘okram’).repeat(out()).emit(hasLabel(‘person’)).path()<br>g.V(‘okram’).emit(hasLabel(‘person’)).repeat(out()).path()</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询顶点'okram'到顶点'Gremlin'之间的路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此外还收集过程中的'person'类型的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'okram'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .repeat(out())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .until(has(<span class="string">'name'</span>, <span class="string">'Gremlin'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .emit(hasLabel(<span class="string">'person'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    .path()</span></pre></td></tr></table></figure><blockquote><p> 注意：<code>emit()</code>与<code>until()</code>搭配使用时，是“或”的关系而不是“与”的关系，满足两者间任意一个即可。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询顶点'okram'的2度OUT可达点的路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此外还收集'person'类型的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'okram'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .repeat(out()).times(<span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .emit(hasLabel(<span class="string">'person'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .path()</span></pre></td></tr></table></figure><blockquote><p> 注意：<code>emit()</code>与<code>times()</code>搭配使用时，是“或”的关系而不是“与”的关系，满足两者间任意一个即可。 </p></blockquote><h4 id="7-2-4、-repeat-loops-：根据最大次数限制来重复执行语句"><a href="#7-2-4、-repeat-loops-：根据最大次数限制来重复执行语句" class="headerlink" title="7.2.4、 repeat() + loops()：根据最大次数限制来重复执行语句"></a>7.2.4、 <code>repeat()</code> + <code>loops()</code>：根据最大次数限制来重复执行语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询顶点'okram'的3度OUT可达点路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'okram'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .repeat(out())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .until(loops().is(<span class="number">3</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .path()</span></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查询顶点&#39;okram&#39;到顶点&#39;Gremlin&#39;之间的路径</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 且之间只相差2跳的距离</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 其中的and()是指两个条件都满足</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V(&#39;okram&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .repeat(out())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .until(has(&#39;name&#39;, &#39;Gremlin&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    .and().loops().is(2))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    .path()</span></pre></td></tr></table></figure><h3 id="7-3、综合运用"><a href="#7-3、综合运用" class="headerlink" title="7.3、综合运用"></a>7.3、综合运用</h3><h4 id="7-3-1、-查找子树"><a href="#7-3-1、-查找子树" class="headerlink" title="7.3.1、 查找子树"></a>7.3.1、 查找子树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找从一个节点出发，到</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 叶子节点结束的所有路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些路径的集合为一颗子树(子图)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'okram'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .repeat(out())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .until(outE().count().is(<span class="number">0</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    .path()</span></pre></td></tr></table></figure><h4 id="7-3-2、-查找两点之间的最短路径"><a href="#7-3-2、-查找两点之间的最短路径" class="headerlink" title="7.3.2、 查找两点之间的最短路径"></a>7.3.2、 查找两点之间的最短路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已知两个顶点'okram'和'javeme'，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过任意关系来找到这两点之间的路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 且限制了最大深度为3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若存在那么第一条结果即是最短路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'okram'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .repeat(bothE().otherV().simplePath())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    .until(hasId(<span class="string">'javeme'</span>).and().loops().is(lte(<span class="number">3</span>)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    .hasId(<span class="string">'javeme'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    .path()</span></pre></td></tr></table></figure><blockquote><p> 注意：<code>bothE().otherV()</code>一般等价于<code>both()</code>，但是在这里有一些差别，后者仅仅返回路径中的顶点信息，前者会把路径中的边信息也返回。 </p></blockquote><h2 id="8-查询结果排序"><a href="#8-查询结果排序" class="headerlink" title="8.查询结果排序"></a>8.查询结果排序</h2><h3 id="8-1、说明"><a href="#8-1、说明" class="headerlink" title="8.1、说明"></a>8.1、说明</h3><p>Gremlin允许对查询的结果进行排序输出，可以指定按某个属性的升序、降序或是随机序的方式输出。排序方式可以通过单独的<code>order()</code>或者<code>order().by(...)</code>指定，而<code>by() step</code>又有一些变种，下面分别讲解<code>order()</code>和<code>order().by(...)</code>的用法。 </p><h4 id="8-1-1、-单独使用order-Step，一般用于遍历器中的元素是属性时："><a href="#8-1-1、-单独使用order-Step，一般用于遍历器中的元素是属性时：" class="headerlink" title="8.1.1、 单独使用order() Step，一般用于遍历器中的元素是属性时："></a>8.1.1、 单独使用<code>order()</code> Step，一般用于遍历器中的元素是属性时：</h4><ul><li>order()会将结果以升序输出； </li></ul><blockquote><p> order()单独使用时，必须保证遍历器（traverser）中的元素是可排序的，在 java 里就是必须实现<code>java.lang.Comparable</code>接口，否则会抛出异常。 </p></blockquote><h4 id="8-1-2、-联合使用order-by-Step，传入排序方式，一般用于遍历器中的元素是属性时："><a href="#8-1-2、-联合使用order-by-Step，传入排序方式，一般用于遍历器中的元素是属性时：" class="headerlink" title="8.1.2、 联合使用order().by(...) Step，传入排序方式，一般用于遍历器中的元素是属性时："></a>8.1.2、 联合使用<code>order().by(...)</code> Step，传入排序方式，一般用于遍历器中的元素是属性时：</h4><ul><li><code>order().by(incr)</code>: 将结果以升序输出，这也是默认的排序方式；</li><li><code>order().by(decr)</code>: 将结果以降序输出；</li><li><code>order().by(shuffle)</code>: 将结果以随机序输出，每次执行结果顺序都可能不一样。</li></ul><blockquote><p> 使用 order().by(…) step 但是 by() 传递的仅是一个排序方式的参数时，也必须保证遍历器（traverser）中的元素是可排序的。 </p></blockquote><h4 id="8-1-3、-联合使用order-by-Step，传入属性和排序方式，用于遍历器中的元素是顶点或边时："><a href="#8-1-3、-联合使用order-by-Step，传入属性和排序方式，用于遍历器中的元素是顶点或边时：" class="headerlink" title="8.1.3、 联合使用order().by(...) Step，传入属性和排序方式，用于遍历器中的元素是顶点或边时："></a>8.1.3、 联合使用<code>order().by(...)</code> Step，传入属性和排序方式，用于遍历器中的元素是顶点或边时：</h4><ul><li>order().by(key): 将结果按照元素属性key的值升序排列，与order().by(key, incr)等效；</li><li>order().by(key, incr): 将结果按照元素属性key的值升序排列；</li><li>order().by(key, decr): 将结果按照元素属性key的值降序排列；</li><li>order().by(key, shuffle): 将结果按照元素属性key的值随机序排列，每次执行结果顺序都可能不一样。</li></ul><blockquote><p>by()step不是一个真正的step，而是一个“step modulator”，与此类似的还有as()和option()step。通过by()step可以为某些step添加traversal、function、comparator等，通常的使用方式是step().by()…by()，某些step只能添加一个by()，而有一些可以添加任意数量的by()step。</p></blockquote><h3 id="8-2、实例讲解"><a href="#8-2、实例讲解" class="headerlink" title="8.2、实例讲解"></a>8.2、实例讲解</h3><h4 id="8-2-1、-order-，使用默认的排序（升序）输出"><a href="#8-2-1、-order-，使用默认的排序（升序）输出" class="headerlink" title="8.2.1、 order()，使用默认的排序（升序）输出"></a>8.2.1、 <code>order()</code>，使用默认的排序（升序）输出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以默认排序输出所有顶点的"name"属性值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().values(<span class="string">'name'</span>).order()</span></pre></td></tr></table></figure><h4 id="8-2-2、-order-by-incr-，指定以升序输出"><a href="#8-2-2、-order-by-incr-，指定以升序输出" class="headerlink" title="8.2.2、 order().by(incr)，指定以升序输出"></a>8.2.2、 <code>order().by(incr)</code>，指定以升序输出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以升序输出所有顶点的"name"属性值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().values(<span class="string">'name'</span>).order().by(incr)</span></pre></td></tr></table></figure><h4 id="8-2-3、-order-by-decr-，指定以降序输出"><a href="#8-2-3、-order-by-decr-，指定以降序输出" class="headerlink" title="8.2.3、 order().by(decr)，指定以降序输出"></a>8.2.3、 <code>order().by(decr)</code>，指定以降序输出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以降序输出所有顶点的"name"属性值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().values(<span class="string">'name'</span>).order().by(decr)</span></pre></td></tr></table></figure><h4 id="8-2-4、-order-by-shuffle-，指定以随机序输出"><a href="#8-2-4、-order-by-shuffle-，指定以随机序输出" class="headerlink" title="8.2.4、 order().by(shuffle)，指定以随机序输出"></a>8.2.4、 <code>order().by(shuffle)</code>，指定以随机序输出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以随机序输出所有顶点的"name"属性值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().values(<span class="string">'name'</span>).order().by(shuffle)</span></pre></td></tr></table></figure><h4 id="8-2-5、-order-by-key-，按照元素属性key的值升序（默认）排列"><a href="#8-2-5、-order-by-key-，按照元素属性key的值升序（默认）排列" class="headerlink" title="8.2.5、 order().by(key)，按照元素属性key的值升序（默认）排列"></a>8.2.5、 <code>order().by(key)</code>，按照元素属性key的值升序（默认）排列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将"person"类型的顶点按照"age"升序（默认）排列输出</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).order().by(<span class="string">'age'</span>)</span></pre></td></tr></table></figure><p> 为了使”age”属性排列显示得更清晰，我们取出顶点的”age”属性 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将"person"类型的顶点按照"age"升序（默认）排列，并获取"age"属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).order().by(<span class="string">'age'</span>).values(<span class="string">'age'</span>)</span></pre></td></tr></table></figure><h4 id="8-2-6、-order-by-key-incr-，按照元素属性key的值升序排列"><a href="#8-2-6、-order-by-key-incr-，按照元素属性key的值升序排列" class="headerlink" title="8.2.6、 order().by(key, incr)，按照元素属性key的值升序排列"></a>8.2.6、 <code>order().by(key, incr)</code>，按照元素属性key的值升序排列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将"person"类型的顶点按照"age"升序排列，并获取"age"属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).order().by(<span class="string">'age'</span>, incr).values(<span class="string">'age'</span>)</span></pre></td></tr></table></figure><h4 id="8-2-7、-order-by-key-desc-，按照元素属性key的值降序排列"><a href="#8-2-7、-order-by-key-desc-，按照元素属性key的值降序排列" class="headerlink" title="8.2.7、 order().by(key, desc)，按照元素属性key的值降序排列"></a>8.2.7、 <code>order().by(key, desc)</code>，按照元素属性key的值降序排列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将"person"类型的顶点按照"age"降序排列输出，并获取"age"属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).order().by(<span class="string">'age'</span>, decr).values(<span class="string">'age'</span>)</span></pre></td></tr></table></figure><h4 id="8-2-8、-order-by-key-shuffle-，按照元素属性key的值随机序排列"><a href="#8-2-8、-order-by-key-shuffle-，按照元素属性key的值随机序排列" class="headerlink" title="8.2.8、 order().by(key, shuffle)，按照元素属性key的值随机序排列"></a>8.2.8、 <code>order().by(key, shuffle)</code>，按照元素属性key的值随机序排列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将"person"类型的顶点按照"age"随机序排列输出，并获取"age"属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).order().by(<span class="string">'age'</span>, shuffle).values(<span class="string">'age'</span>)</span></pre></td></tr></table></figure><h2 id="9-数据分组与去重"><a href="#9-数据分组与去重" class="headerlink" title="9.数据分组与去重"></a>9.数据分组与去重</h2><p>Gremlin支持对数据进行分组和去重。</p><p>数据分组是指：从某个维度上对拥有相同点的数据进行分组，比如根据年龄分组、根据出生省份分组等。</p><p>数据去重是指：去除结果集中相同的元素，或者去除在某个维度上具有相同点的数据，比如根据年龄选出一些代表，每个年龄最多只能有一个人。</p><p>下面讲解实现上述功能的具体Step：</p><ul><li>group(): 对结果集进行分组，可通过by(property)来指定根据什么维度进行分组，可称维度为分组键；如果不指定维度则以元素id作为分组键，相当于重复的元素被分为一组。每一组由分组键+组内元素列表构成。如果有需要也可对每一组的元素列表进行reduce操作，依然使用by()语句，如by(count())对组内元素计数。</li><li>groupCount(): 对结果集进行分组，并统计每一组的元素个数。每一组由分组键+组内元素数量构成。</li><li>dedup(): 去除结果集中相同的元素，可通过by(property)来指定根据什么维度进行去重。</li><li>by(): 语义上一般指“根据什么维度”，与上述语句配合使用，如group().by()、dedup().by()等。也可与其它语句配合，如前面讲到的排序order().by()及路径path().by()等。</li></ul><h3 id="9-1、实例讲解"><a href="#9-1、实例讲解" class="headerlink" title="9.1、实例讲解"></a>9.1、实例讲解</h3><ul><li><code>group()</code>：对结果集进行分组 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不指定任何维度进行分组</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).group()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不指定任何维度进行分组</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 但数据集中有重复的元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重复的元素将会被分为一组</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V().both().hasLabel(<span class="string">'person'</span>).group()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据年龄进行分组</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).group().by(<span class="string">'age'</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据年龄进行分组</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并统计各个年龄的人数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .group()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .by(<span class="string">'age'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .by(count())</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据顶点类别进行分组</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并统计各个类别的数量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V().group().by(label).by(count())</span></pre></td></tr></table></figure><ul><li><code>groupCount()</code>：对结果集进行分组计数 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不指定任何维度进行分组计数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).groupCount()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不指定任何维度进行分组计数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 但数据集中有重复的元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重复的元素将会被分为一组</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V().both().hasLabel(<span class="string">'person'</span>).groupCount()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据年龄进行分组计数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .groupCount()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .by(<span class="string">'age'</span>)</span></pre></td></tr></table></figure><ul><li><code>dedup()</code>：去除结果集中重复的元素 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对一组含有重复顶点的数据进行去重</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().both().hasLabel(<span class="string">'person'</span>).dedup()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看所有人当中有哪几种年龄</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 人之间的年龄是可能有重复的，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过dedup去除掉重复的年龄</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .values(<span class="string">'age'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .dedup()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从各个年龄的人中选出一个代表</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).dedup().by(<span class="string">'age'</span>)</span></pre></td></tr></table></figure><h3 id="9-2、综合运用"><a href="#9-2、综合运用" class="headerlink" title="9.2、综合运用"></a>9.2、综合运用</h3><ul><li>获得各个地方人们的平均年龄 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据地域分组，并得到各个组的平均年龄</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .group()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .by(<span class="string">'addr'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .by(values(<span class="string">'age'</span>).mean())</span></pre></td></tr></table></figure><ul><li>统计顶点的边数量的分布情况</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拥有相同数量边的顶点作为一组</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并获取每一组的顶点数量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果相当于：拥有m条边的顶点有n个</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V().groupCount().by(bothE().count())</span></pre></td></tr></table></figure><h2 id="10-条件和过滤"><a href="#10-条件和过滤" class="headerlink" title="10.条件和过滤"></a>10.条件和过滤</h2><h3 id="10-1、条件和过滤操作说明"><a href="#10-1、条件和过滤操作说明" class="headerlink" title="10.1、条件和过滤操作说明"></a>10.1、条件和过滤操作说明</h3><p>在对图进行遍历分析时，经常需要对满足一定条件的对象进行过滤。where()就是用来过滤遍历过程中当前阶段的对象。另一方面，predicate就是过滤时使用的判断条件，包括关系运算和区间判断等，只有满足判断条件的对象才能通过进入下一轮或者作为结果。</p><p>where()常与select()或者match()配合使用，也可以单独使用。</p><p>以下是predicate的说明：</p><table><thead><tr><th>谓语</th><th>说明</th></tr></thead><tbody><tr><td>eq(object)</td><td>传入的对象等于目标object?</td></tr><tr><td>neq(object)</td><td>传入的对象不等于目标object?</td></tr><tr><td>lt(number)</td><td>传入的数字小于目标number?</td></tr><tr><td>lte(number)</td><td>传入的数字小于或等于目标number?</td></tr><tr><td>gt(number)</td><td>传入的数字大于目标number?</td></tr><tr><td>gte(number)</td><td>传入的数字大于或等于目标number?</td></tr><tr><td>inside(low,high)</td><td>传入的数字大于low且小于high?</td></tr><tr><td>outside(low,high)</td><td>传入的数字小于low或者大于high?</td></tr><tr><td>between(low,high)</td><td>传入的数字大于等于low且小于high?</td></tr><tr><td>within(objects…)</td><td>传入的对象等于目标对象列表objects中的任意一个?</td></tr><tr><td>without(objects…)</td><td>传入的对象不等于目标对象列表objects中的任何一个?</td></tr></tbody></table><blockquote><p> 逻辑运算and()、or()或者not()作用于<code>predicate</code>会产生一个新的<code>predicate</code></p></blockquote><p> 在众多的Gremlin steps中，有一大类是<code>filter step</code>，通过判断是否满足<code>predicate</code>来决定对象能否通过<code>filter step</code>。<code>filter()</code>语句是<code>filter step</code>的基础，较为抽象，而更加具体的<code>where()</code>语句就是一个典型的<code>filter step</code>。 </p><h3 id="10-2、实例说明"><a href="#10-2、实例说明" class="headerlink" title="10.2、实例说明"></a>10.2、实例说明</h3><h4 id="10-2-1、predicate可以通过test-来获得boolean值"><a href="#10-2-1、predicate可以通过test-来获得boolean值" class="headerlink" title="10.2.1、predicate可以通过test()来获得boolean值"></a>10.2.1、<code>predicate</code>可以通过<code>test()</code>来获得boolean值</h4><p> 可以用<code>test()</code>测试<code>value</code>是否满足<code>predicate</code>，以下是一些例子： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// (3 == 2)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">eq(<span class="number">2</span>).test(<span class="number">3</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// ('d' == 'a' || 'd' == 'b' || 'd' == 'c')</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">within(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>).test(<span class="string">'d'</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// (3 &gt; 1 &amp;&amp; 3 &lt; 4)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">inside(<span class="number">1</span>,<span class="number">4</span>).test(<span class="number">3</span>)</span></pre></td></tr></table></figure><h4 id="10-2-2、and-or-not作用于predicate之后成为新的predicate"><a href="#10-2-2、and-or-not作用于predicate之后成为新的predicate" class="headerlink" title="10.2.2、and/or/not作用于predicate之后成为新的predicate"></a>10.2.2、<code>and</code>/<code>or</code>/<code>not</code>作用于<code>predicate</code>之后成为新的<code>predicate</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// not()作用于neq()，等价于eq()</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">not(neq(<span class="number">2</span>))</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// and()连接的predicate，是一个新的predicate</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">within(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>).and(not(eq(<span class="number">2</span>))).test(<span class="number">3</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// or()连接的predicate，是一个新的predicate</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">inside(<span class="number">1</span>,<span class="number">4</span>).or(eq(<span class="number">5</span>)).test(<span class="number">3</span>)</span></pre></td></tr></table></figure><h4 id="10-2-3、where-单独使用"><a href="#10-2-3、where-单独使用" class="headerlink" title="10.2.3、where()单独使用"></a>10.2.3、<code>where()</code>单独使用</h4><p><code>where()</code>有三种使用方式：</p><ul><li><code>where(P)</code></li><li><code>where(String, P)</code></li><li><code>where(Traversal)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看“zhoney”的合作伙伴</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// where(P)方式</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'zhoney'</span>).as(<span class="string">'a'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .out(<span class="string">'created'</span>).in(<span class="string">'created'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .where(neq(<span class="string">'a'</span>))</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看“zhoney”的合作伙伴</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// where(String, P)方式</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'zhoney'</span>).as(<span class="string">'a'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .out(<span class="string">'created'</span>).in(<span class="string">'created'</span>).as(<span class="string">'b'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .where(<span class="string">'a'</span>,neq(<span class="string">'b'</span>))</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// “spmallette”开发过不止一个软件的合作伙伴</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// where(Traversal)方式</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'spmallette'</span>).out(<span class="string">'created'</span>).in(<span class="string">'created'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .where(out(<span class="string">'created'</span>).count().is(gt(<span class="number">1</span>)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .values(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询”被别人认识“</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 且认识自己的人的年龄大于自己的年龄的人</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V().as(<span class="string">'a'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .out(<span class="string">'knows'</span>).as(<span class="string">'b'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .where(<span class="string">'a'</span>, gt(<span class="string">'b'</span>)).by(<span class="string">'age'</span>)</span></pre></td></tr></table></figure><h4 id="10-2-4、where-与as-select-配合使用"><a href="#10-2-4、where-与as-select-配合使用" class="headerlink" title="10.2.4、where()与as()+select()配合使用"></a>10.2.4、<code>where()</code>与<code>as()</code>+<code>select()</code>配合使用</h4><p> <code>as()</code>可以为某一阶段的对象添加标签，<code>select()</code>则可以通过标签获取对象。因此<code>as()</code>+<code>select()</code>可以在某个step处得到历史信息 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看“zhoney”的合作伙伴，并将“zhoney”及其合作伙伴的名字以map输出</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// select().where()方式</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'zhoney'</span>).as(<span class="string">'a'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .out(<span class="string">'created'</span>).in(<span class="string">'created'</span>).as(<span class="string">'b'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .select(<span class="string">'a'</span>,<span class="string">'b'</span>).by(<span class="string">'name'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .where(<span class="string">'a'</span>,neq(<span class="string">'b'</span>))</span></pre></td></tr></table></figure><h4 id="10-2-5、where-与match-配合使用"><a href="#10-2-5、where-与match-配合使用" class="headerlink" title="10.2.5、where()与match()配合使用"></a>10.2.5、<code>where()</code>与<code>match()</code>配合使用</h4><p> <code>match()</code>可以保证满足某种模式的对象通过 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看“zhoney”的合作伙伴，并将“zhoney”及其合作伙伴的名字以map输出</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// match().where()方式</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'zhoney'</span>).match(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    __.as(<span class="string">'a'</span>).out(<span class="string">'created'</span>).as(<span class="string">'b'</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">__.as(<span class="string">'b'</span>).in(<span class="string">'created'</span>).as(<span class="string">'c'</span>)).where(<span class="string">'a'</span>, neq(<span class="string">'c'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">).select(<span class="string">'a'</span>,<span class="string">'c'</span>).by(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><h4 id="10-2-6、filter"><a href="#10-2-6、filter" class="headerlink" title="10.2.6、filter()"></a>10.2.6、filter()</h4><p><code>filter()</code>有三种用法：</p><ul><li>lambda方式，filter{it.get()…}</li><li>Traversal方式，filter(Traversal)</li><li>特定filter step方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找图中的“person”顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambda方式</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V().filter &#123;it.get().label() == <span class="string">'person'</span>&#125;</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找图中的“person”顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Traversal方式</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V().filter(label().is(<span class="string">'person'</span>))</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找图中的“person”顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特定filter step方式</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>)</span></pre></td></tr></table></figure><h2 id="11-逻辑运算"><a href="#11-逻辑运算" class="headerlink" title="11.逻辑运算"></a>11.逻辑运算</h2><h3 id="11-1、说明"><a href="#11-1、说明" class="headerlink" title="11.1、说明"></a>11.1、说明</h3><p>Gremlin支持在遍历器上加上逻辑运算进行过滤，只有满足该逻辑条件的元素才会进入下一个遍历器中。</p><p>下面讲解实现上述功能的具体Step：</p><ul><li><code>is()</code>：可以接受一个对象（能判断相等）或一个判断语句（如：<code>P.gt()</code>、<code>P.lt()</code>、<code>P.inside()</code>等），当接受的是对象时，原遍历器中的元素必须与对象相等才会保留；当接受的是判断语句时，原遍历器中的元素满足判断才会保留，其实接受一个对象相当于<code>P.eq()</code>； </li><li><code>and()</code>：可以接受任意数量的遍历器（traversal），原遍历器中的元素，只有在每个新遍历器中都能生成至少一个输出的情况下才会保留，相当于过滤器组合的与条件； </li><li><code>or()</code>：可以接受任意数量的遍历器（traversal），原遍历器中的元素，只要在全部新遍历器中能生成至少一个输出的情况下就会保留，相当于过滤器组合的或条件； </li><li><code>not()</code>：仅能接受一个遍历器（traversal），原遍历器中的元素，在新遍历器中能生成输出时会被移除，不能生成输出时则会保留，相当于过滤器的非条件。 </li></ul><blockquote><p> 这四种逻辑运算Step除了像一般的Step写法以外，<code>and()</code>和<code>or()</code>还可以放在<code>where()</code>中以中缀符的形式出现。 </p></blockquote><h3 id="11-2、实例讲解"><a href="#11-2、实例讲解" class="headerlink" title="11.2、实例讲解"></a>11.2、实例讲解</h3><h4 id="11-2-1、-is"><a href="#11-2-1、-is" class="headerlink" title="11.2.1、 is()"></a>11.2.1、 <code>is()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 筛选出顶点属性“age”等于28的属性值，与`is(P.eq(28))`等效</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().values(<span class="string">'age'</span>).is(<span class="number">28</span>)</span></pre></td></tr></table></figure><blockquote><p> 当没有任何一个顶点的属性“age”为28时，输出为空。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 筛选出顶点属性“age”大于等于28的属性值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().values(<span class="string">'age'</span>).is(gte(<span class="number">28</span>))</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 筛选出顶点属性“age”属于区间（27，29）的属性值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().values(<span class="string">'age'</span>).is(inside(<span class="number">27</span>, <span class="number">29</span>))</span></pre></td></tr></table></figure><blockquote><p> <code>P.inside(a, b)</code>是左开右开区间（a，b） </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 筛选出由两个或两个以上的人参与创建（“created”）的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：这里筛选的是顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V().where(__.in(<span class="string">'created'</span>).count().is(gt(<span class="number">2</span>))).values(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><blockquote><p> <code>where()</code>Step可以接受一些过滤条件 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 筛选出有创建者（“created”）的年龄（“age”）在20～29之间的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().where(__.in(<span class="string">'created'</span>).values(<span class="string">'age'</span>).is(between(<span class="number">20</span>, <span class="number">29</span>))).values(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><h4 id="11-2-2、-and-，逻辑与"><a href="#11-2-2、-and-，逻辑与" class="headerlink" title="11.2.2、 and()，逻辑与"></a>11.2.2、 <code>and()</code>，逻辑与</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有包含出边“supports”的顶点的名字“name”</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().and(outE(<span class="string">'supports'</span>)).values(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有包含出边“supports”和“implements”的顶点的名字“name”</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().and(outE(<span class="string">'supports'</span>), outE(<span class="string">'implements'</span>)).values(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含边“created”并且属性“age”为28的顶点的名字“name”</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().and(outE(<span class="string">'created'</span>), values(<span class="string">'age'</span>).is(<span class="number">28</span>)).values(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><p> 上面的缀符写法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含边“created”并且属性“age”为28的顶点的名字“name”</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().where(outE(<span class="string">'created'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">            .and()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            .values(<span class="string">'age'</span>).is(<span class="number">28</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"> .values(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><h4 id="11-2-3、-or-，逻辑或"><a href="#11-2-3、-or-，逻辑或" class="headerlink" title="11.2.3、 or()，逻辑或"></a>11.2.3、 <code>or()</code>，逻辑或</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有包含出边“supports”的顶点的名字“name”</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().or(outE(<span class="string">'supports'</span>)).values(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><blockquote><p> 只有一个条件时，<code>and()</code>与<code>or()</code>的效果一样的。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有包含出边“supports”或“implements”的顶点的名字“name”</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().or(outE(<span class="string">'supports'</span>), outE(<span class="string">'implements'</span>)).values(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><blockquote><p> 注意对比与<code>g.V().and(outE(&#39;supports&#39;), outE(&#39;implements&#39;)).values(&#39;name&#39;)</code>的差别 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含边“created”或属性“age”为28的顶点的名字“name”</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().or(outE(<span class="string">'created'</span>), values(<span class="string">'age'</span>).is(<span class="number">28</span>)).values(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><blockquote><p> 注意对比与<code>g.V().and(outE(&#39;created&#39;), values(&#39;age&#39;).is(28)).values(&#39;name&#39;)</code>的差别 </p></blockquote><p>上面的 缀符写法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含边“created”或属性“age”为28的顶点的名字“name”</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().where(outE(<span class="string">'created'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">            .or()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            .values(<span class="string">'age'</span>).is(<span class="number">28</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"> .values(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><h4 id="11-2-4、-not-，逻辑非"><a href="#11-2-4、-not-，逻辑非" class="headerlink" title="11.2.4、 not()，逻辑非"></a>11.2.4、 <code>not()</code>，逻辑非</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 筛选出所有不是“person”的顶点的“label”</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().not(hasLabel(<span class="string">'person'</span>)).label()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 筛选出所有包含不少于两条（大于等于两条）“created”边的“person”的名字“name”</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).not(out(<span class="string">'created'</span>).count().is(lt(<span class="number">2</span>))).values(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><h3 id="11-3、综合运用"><a href="#11-3、综合运用" class="headerlink" title="11.3、综合运用"></a>11.3、综合运用</h3><p> 目标：获取所有最多只有一条“created”边并且年龄不等于28的“person”顶点 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与（含有小于等于一条“created”边，年龄不等于28）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .and(outE(<span class="string">'created'</span>).count().is(lte(<span class="number">1</span>)),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">         values(<span class="string">"age"</span>).is(P.not(P.eq(<span class="number">28</span>))))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .values(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非（或（含有多于一条“created”边，年龄等于28））</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .not(or(out(<span class="string">'created'</span>).count().is(gt(<span class="number">1</span>)),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            values(<span class="string">'age'</span>).is(<span class="number">28</span>)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .values(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><h2 id="12-统计运算"><a href="#12-统计运算" class="headerlink" title="12.统计运算"></a>12.统计运算</h2><h3 id="12-1、说明"><a href="#12-1、说明" class="headerlink" title="12.1、说明"></a>12.1、说明</h3><p>Gremlin可以在Number类型的流（遍历器）上做简单的统计运算，包括计算总和、最大值、最小值、均值。</p><p>下面讲解实现上述功能的具体Step：</p><ul><li><code>sum()</code>：将流上的所有的数字求和；</li><li><code>max()</code>：对流上的所有的数字求最大值；</li><li><code>min()</code>：对流上的所有的数字求最小值；</li><li><code>mean()</code>：将流上的所有的数字求均值；</li></ul><blockquote><p> 这四种Step只能作用在Number类型的流上，在java里就是继承自<code>java.lang.Number</code>类。 </p></blockquote><h3 id="12-2、实例讲解"><a href="#12-2、实例讲解" class="headerlink" title="12.2、实例讲解"></a>12.2、实例讲解</h3><h4 id="12-2-1、-sum"><a href="#12-2-1、-sum" class="headerlink" title="12.2.1、 sum()"></a>12.2.1、 <code>sum()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算所有“person”的“age”的总和</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).values(<span class="string">'age'</span>).sum()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算所有“person”的“created”出边数的总和</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).map(outE(<span class="string">'created'</span>).count()).sum()</span></pre></td></tr></table></figure><h4 id="12-2-2、-max"><a href="#12-2-2、-max" class="headerlink" title="12.2.2、 max()"></a>12.2.2、 <code>max()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算所有“person”的“age”中的最大值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).values(<span class="string">'age'</span>).max()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算所有“person”的“created”出边数的最大值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).map(outE(<span class="string">'created'</span>).count()).max()</span></pre></td></tr></table></figure><h4 id="12-2-3、-min"><a href="#12-2-3、-min" class="headerlink" title="12.2.3、 min()"></a>12.2.3、 <code>min()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算所有“person”的“age”中的最小值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).values(<span class="string">'age'</span>).min()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算所有“person”的“created”出边数的最小值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).map(outE(<span class="string">'created'</span>).count()).min()</span></pre></td></tr></table></figure><h4 id="12-2-4、-mean"><a href="#12-2-4、-mean" class="headerlink" title="12.2.4、 mean()"></a>12.2.4、 <code>mean()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算所有“person”的“age”的均值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).values(<span class="string">'age'</span>).mean()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算所有“person”的“created”出边数的均值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).map(outE(<span class="string">'created'</span>).count()).mean()</span></pre></td></tr></table></figure><h2 id="13-数学运算"><a href="#13-数学运算" class="headerlink" title="13.数学运算"></a>13.数学运算</h2><h3 id="13-1、说明"><a href="#13-1、说明" class="headerlink" title="13.1、说明"></a>13.1、说明</h3><p> 在Gremlin中有一个专门负责科学计算功能的step <code>math()</code>。 <code>math()</code> 不同于常见的函数组合和嵌套形式，提供了一种易于读取的基于字符串的数学处理器。 </p><ul><li><p><code>math()</code> 支持<code>by()</code>，其中多个<code>by()</code> 按照在<code>math()运算表达式</code>中首次引用变量的顺序应用。</p></li><li><p>保留变量<code>_</code>是指传入<code>math()</code>的当前遍历器对象。</p></li></ul><p>math()<code>支持的运算符包括：</code>+<code>，</code>-<code>，</code>*<code>，</code>/<code>，</code>%<code>，</code>^</p><ul><li><code>math()</code>支持的内嵌函数包括：</li><li><code>abs</code>: absolute value，绝对值</li><li><code>acos</code>: arc cosine，反余弦</li><li><code>asin</code>: arc sine，反正弦</li><li><code>atan</code>: arc tangent，反正切</li><li><code>cbrt</code>: cubic root，立方根</li><li><code>ceil</code>: nearest upper integer，向上最接近的整数</li><li><code>cos</code>: cosine，余弦</li><li><code>cosh</code>: hyperbolic cosine，双曲余弦</li><li><code>exp</code>: euler’s number raised to the power (e^x)，以e为底的指数</li><li><code>floor</code>: nearest lower integer，向下最近接的整数</li><li><code>log</code>: logarithmus naturalis (base e)，以e为底的对数</li><li><code>log10</code>: logarithm (base 10)，以10为底的对数</li><li><code>log2</code>: logarithm (base 2)，以2为底的对数</li><li><code>sin</code>: sine，正弦</li><li><code>sinh</code>: hyperbolic sine，双曲正弦</li><li><code>sqrt</code>: square root，平方根</li><li><code>tan</code>: tangent，正切</li><li><code>tanh</code>: hyperbolic tangent，双曲正切</li><li><code>signum</code>: signum function，签名功能</li></ul><h3 id="13-2、实例讲解"><a href="#13-2、实例讲解" class="headerlink" title="13.2、实例讲解"></a>13.2、实例讲解</h3><p> （待补充…） </p><h2 id="14-路径选取与过滤"><a href="#14-路径选取与过滤" class="headerlink" title="14.路径选取与过滤"></a>14.路径选取与过滤</h2><h3 id="14-1、说明"><a href="#14-1、说明" class="headerlink" title="14.1、说明"></a>14.1、说明</h3><p>Gremlin支持从走过的路径里选取部分数据作为结果，并且可以在选取时进行条件过滤。</p><p>下面讲解实现上述功能的具体Step：</p><ul><li>as()+select(): 对路径中结果进行选取，首先通过as(label)对任意步骤打上标签，然后使用select(label)来选取若干历史步骤的结果作为新结果。此外还可通过select().by(property)来指定根据什么维度进行选取。</li><li>as()+where(): 以条件匹配的方式进行路径结果选取，只有符合条件的路径才能被选取出来。</li><li>as()+match(): 以模式匹配的方式进行路径结果选取，只有符合模式的路径才能被选取出来。</li><li>as()+dedup(): 根据路径中的若干步骤的结果进行去重，只有首次出现的路径段才能被选取出来。</li></ul><h3 id="14-2、实例讲解"><a href="#14-2、实例讲解" class="headerlink" title="14.2、实例讲解"></a>14.2、实例讲解</h3><h4 id="14-2-1、-as-select-：对路径中结果进行选取"><a href="#14-2-1、-as-select-：对路径中结果进行选取" class="headerlink" title="14.2.1、 as()...select()：对路径中结果进行选取"></a>14.2.1、 <code>as()...select()</code>：对路径中结果进行选取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从路径中选取第1步和第3步的结果作为最终结果</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'2:HugeGraph'</span>).as(<span class="string">'a'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .out().as(<span class="string">'b'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .out().as(<span class="string">'c'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .select(<span class="string">'a'</span>, <span class="string">'c'</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从集合中选择最后一个元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'2:HugeGraph'</span>).as(<span class="string">"a"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .repeat(out().as(<span class="string">"a"</span>)).times(<span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .select(last, <span class="string">"a"</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过by()来指定选取的维度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'2:HugeGraph'</span>).as(<span class="string">'a'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .out().as(<span class="string">'b'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .out().as(<span class="string">'c'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .select(<span class="string">'a'</span>, <span class="string">'c'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .by(<span class="string">'name'</span>).by(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从map中选择指定key的值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().valueMap().select(<span class="string">'tag'</span>).dedup()</span></pre></td></tr></table></figure><h4 id="14-2-2、-as-where-：以条件匹配的方式进行路径结果选取"><a href="#14-2-2、-as-where-：以条件匹配的方式进行路径结果选取" class="headerlink" title="14.2.2、 as()...where()：以条件匹配的方式进行路径结果选取"></a>14.2.2、 <code>as()...where()</code>：以条件匹配的方式进行路径结果选取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选取满足第1步和第3步“lang”属性相等的路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'2:HugeGraph'</span>).as(<span class="string">'a'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .out().as(<span class="string">'b'</span>).out().as(<span class="string">'c'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .where(<span class="string">'a'</span>, eq(<span class="string">'c'</span>)).by(<span class="string">'lang'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .select(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>).by(id)</span></pre></td></tr></table></figure><h4 id="14-2-3、-as-match-：以模式匹配的方式进行路径结果选取"><a href="#14-2-3、-as-match-：以模式匹配的方式进行路径结果选取" class="headerlink" title="14.2.3、 as()+match()：以模式匹配的方式进行路径结果选取"></a>14.2.3、 <code>as()+match()</code>：以模式匹配的方式进行路径结果选取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选取满足两个模式的路径：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.第3步有OUT节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.第3步的OUT节点的指定路径不允许回到第二步的节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'2:HugeGraph'</span>).as(<span class="string">'a'</span>).out().as(<span class="string">'b'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"> .match(__.as(<span class="string">'b'</span>).out().as(<span class="string">'c'</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        __.not(__.as(<span class="string">'c'</span>).out().in(<span class="string">'define'</span>).as(<span class="string">'b'</span>)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"> .select(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>).by(id)</span></pre></td></tr></table></figure><h4 id="14-2-4、-as-debup-：路径去重"><a href="#14-2-4、-as-debup-：路径去重" class="headerlink" title="14.2.4、 as()+debup()：路径去重"></a>14.2.4、 <code>as()+debup()</code>：路径去重</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以路径中的前3步作为去重依据，对路径进行去重</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'2:HugeGraph'</span>).as(<span class="string">'a'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .out().as(<span class="string">'b'</span>).out().as(<span class="string">'c'</span>).in()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .dedup(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>).path()</span></pre></td></tr></table></figure><h3 id="14-3、综合运用"><a href="#14-3、综合运用" class="headerlink" title="14.3、综合运用"></a>14.3、综合运用</h3><h4 id="14-3-1、-查询支持Gremlin语言的软件，至少由2个相互认识的且在北京的作者完成"><a href="#14-3-1、-查询支持Gremlin语言的软件，至少由2个相互认识的且在北京的作者完成" class="headerlink" title="14.3.1、 查询支持Gremlin语言的软件，至少由2个相互认识的且在北京的作者完成"></a>14.3.1、 查询支持Gremlin语言的软件，至少由2个相互认识的且在北京的作者完成</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取支持Gremlin语言的软件，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并且作者是至少为2个相互认识的人，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 且这两个作者都在北京</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:Gremlin'</span>).in(<span class="string">'supports'</span>).as(<span class="string">'software'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .match(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    __.as(<span class="string">'software'</span>).in(<span class="string">'created'</span>).as(<span class="string">'person1'</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    __.as(<span class="string">'person1'</span>).both(<span class="string">'knows'</span>).as(<span class="string">'person2'</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    __.as(<span class="string">'person2'</span>).out(<span class="string">'created'</span>).as(<span class="string">'software'</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    __.as(<span class="string">'person1'</span>).has(<span class="string">'addr'</span>, <span class="string">'Beijing'</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    __.as(<span class="string">'person2'</span>).has(<span class="string">'addr'</span>, <span class="string">'Beijing'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    .select(<span class="string">'software'</span>).dedup()</span></pre></td></tr></table></figure><h4 id="14-3-2、-查询支持Gremlin语言的软件的作者，并按边权重排序"><a href="#14-3-2、-查询支持Gremlin语言的软件的作者，并按边权重排序" class="headerlink" title="14.3.2、 查询支持Gremlin语言的软件的作者，并按边权重排序"></a>14.3.2、 查询支持Gremlin语言的软件的作者，并按边权重排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取支持Gremlin语言的软件，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查找其作者，并对中间经过的边打标签</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照边的权重进行排序</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选取软件、权重、作者作为结果</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:Gremlin'</span>).in(<span class="string">'supports'</span>).as(<span class="string">'s'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .inE(<span class="string">'created'</span>).as(<span class="string">'e'</span>).outV().as(<span class="string">'t'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    .order().by(select(<span class="string">'e'</span>).by(<span class="string">'weight'</span>), decr)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    .select(<span class="string">'s'</span>, <span class="string">'e'</span>, <span class="string">'t'</span>).by(<span class="string">'name'</span>).by(<span class="string">'weight'</span>)</span></pre></td></tr></table></figure><h2 id="15-分支"><a href="#15-分支" class="headerlink" title="15.分支"></a>15.分支</h2><h3 id="15-1、说明"><a href="#15-1、说明" class="headerlink" title="15.1、说明"></a>15.1、说明</h3><p>在对图进行遍历分析时，有时需要根据某些条件对当前的对象集合进行不同的操作，也就是if-then-else语法结构。Gremlin中有一类step可以满足这种分支需求，这组step叫做branch step。branch()是这类step的基础，比较抽象，而choose()是典型的branch step。<br> <code>choose()</code>的基本使用方法有两类： </p><ul><li><p>单独使用，choose(predicate, true-traversal, false-traversal)：根据predicate判断，当前对象满足时，继续true-traversal，否则继续false-traversal</p></li><li><p>与option配合使用，choose(traversal).option(value1, traversal1).option(…)…：根据对象通过traversal的结果决定后续操作，如果结果是value1，则该对象继续traversal1，以此类推</p></li></ul><p>option()不是一种Gremlin step，只是一种辅助语法，可与choose()配合使用</p><h3 id="15-2、实例讲解"><a href="#15-2、实例讲解" class="headerlink" title="15.2、实例讲解"></a>15.2、实例讲解</h3><h4 id="15-2-1、if-then-else型choose-语句"><a href="#15-2-1、if-then-else型choose-语句" class="headerlink" title="15.2.1、if-then-else型choose()语句"></a>15.2.1、<code>if-then-else</code>型<code>choose()</code>语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找所有的“person”类型的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果“age”属性小于等于20，输出他的朋友的名字</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果“age”属性大于20，输出他开发的软件的名字</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// choose(condition, true-action, false-action)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .choose(values(<span class="string">'age'</span>).is(lte(<span class="number">20</span>)),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            __.in(<span class="string">'knows'</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            __.out(<span class="string">'created'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    .values(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><h4 id="15-2-2、option-型choose-语句"><a href="#15-2-2、option-型choose-语句" class="headerlink" title="15.2.2、option()型choose()语句"></a>15.2.2、<code>option()</code>型<code>choose()</code>语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找所有的“person”类型的顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果“age”属性等于0，输出名字</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果“age”属性等于28，输出年龄</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果“age”属性等于29，输出他开发的软件的名字</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// choose(predicate).option().option()...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    .choose(values(<span class="string">'age'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    .option(<span class="number">0</span>, values(<span class="string">'name'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    .option(<span class="number">28</span>, values(<span class="string">'age'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    .option(<span class="number">29</span>, __.out(<span class="string">'created'</span>).values(<span class="string">'name'</span>))</span></pre></td></tr></table></figure><h4 id="15-2-3、如果choose-predicate-true-traversal-false-traversal-中false-traversal为空或者是identity-，则不满足条件的对象直接通过choose"><a href="#15-2-3、如果choose-predicate-true-traversal-false-traversal-中false-traversal为空或者是identity-，则不满足条件的对象直接通过choose" class="headerlink" title="15.2.3、如果choose(predicate, true-traversal, false-traversal)中false-traversal为空或者是identity()，则不满足条件的对象直接通过choose()"></a>15.2.3、如果<code>choose(predicate, true-traversal, false-traversal)</code>中<code>false-traversal</code>为空或者是<code>identity()</code>，则不满足条件的对象直接通过<code>choose()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找所有顶点，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型为“person”的顶点输出其创建的软件的“name”属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 否则输出顶点自身的“name”属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V().choose(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    hasLabel(<span class="string">'person'</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    out(<span class="string">'created'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"> .values(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找所有顶点，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型为“person”的顶点输出其创建的软件的“name”属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 否则输出顶点自身的“name”属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V().choose(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    hasLabel(<span class="string">'person'</span>), </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    out(<span class="string">'created'</span>), </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    identity())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    .values(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><h4 id="15-2-4、choose-和option-配合使用时，还提供了一个none，不满足其他选项的对象，执行none选项的traversal"><a href="#15-2-4、choose-和option-配合使用时，还提供了一个none，不满足其他选项的对象，执行none选项的traversal" class="headerlink" title="15.2.4、choose()和option()配合使用时，还提供了一个none，不满足其他选项的对象，执行none选项的traversal"></a>15.2.4、<code>choose()</code>和<code>option()</code>配合使用时，还提供了一个<code>none</code>，不满足其他选项的对象，执行<code>none</code>选项的<code>traversal</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找所有类型为“person”的顶点，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// “name”属性为“Zhoney Zhang”的输出其“age”属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 否则输出顶点的“name”属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .choose(values(<span class="string">'name'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .option(<span class="string">'Zhoney Zhang'</span>, values(<span class="string">'age'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    .option(none, values(<span class="string">'name'</span>))</span></pre></td></tr></table></figure><h4 id="15-2-5、branch"><a href="#15-2-5、branch" class="headerlink" title="15.2.5、branch()"></a>15.2.5、<code>branch()</code></h4><p><code>branch()</code>有三种用法：</p><ul><li>lambda方式，filter{it.get()…}</li><li>Traversal方式，filter(Traversal)</li><li>特定branch step方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// “name”属性值为“HugeGraph”的顶点输出其“lang”属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// “name”属性值不为“HugeGraph”的顶点输出其“name”属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambda方式</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">g.V().branch &#123;it.get().value(<span class="string">'name'</span>)&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">.option(<span class="string">'HugeGraph'</span>, values(<span class="string">'lang'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    .option(none, values(<span class="string">'name'</span>))</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// “name”属性值为“HugeGraph”的顶点输出其“lang”属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// “name”属性值不为“HugeGraph”的顶点输出其“name”属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// traversal方式</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">g.V().branch(values(<span class="string">'name'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .option(<span class="string">'HugeGraph'</span>, values(<span class="string">'lang'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    .option(none, values(<span class="string">'name'</span>))</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// “name”属性值为“HugeGraph”的顶点输出其“lang”属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// “name”属性值不为“HugeGraph”的顶点输出其“name”属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特定branch step方式</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">g.V().choose(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    has(<span class="string">'name'</span>,<span class="string">'HugeGraph'</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    values(<span class="string">'lang'</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    values(<span class="string">'name'</span>))</span></pre></td></tr></table></figure><h2 id="16-合并"><a href="#16-合并" class="headerlink" title="16.合并"></a>16.合并</h2><h3 id="16-1、说明"><a href="#16-1、说明" class="headerlink" title="16.1、说明"></a>16.1、说明</h3><ul><li>coalesce: 可以接受任意数量的遍历器（traversal），按顺序执行，并返回第一个能产生输出的遍历器的结果；</li><li>optional: 只能接受一个遍历器（traversal），如果该遍历器能产生一个结果，则返回该结果，否则返回调用optionalStep的元素本身。当连续使用.optional()时，如果在某一步返回了调用元素本身，则后续的.optional()不会继续执行；</li><li>union: 可以接受任意数量的遍历器（traversal），并能够将各个遍历器的输出合并到一起；</li></ul><h3 id="16-2、实例讲解"><a href="#16-2、实例讲解" class="headerlink" title="16.2、实例讲解"></a>16.2、实例讲解</h3><h4 id="16-2-1、-coalesce"><a href="#16-2-1、-coalesce" class="headerlink" title="16.2.1、 coalesce()"></a>16.2.1、 <code>coalesce()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按优先级寻找到顶点“HugeGraph”的以下边和邻接点，找到一个就停止</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、“implements”出边和邻接点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2、“supports”出边和邻接点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3、“created”入边和邻接点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:HugeGraph'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .coalesce(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        outE(<span class="string">'implements'</span>), </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        outE(<span class="string">'supports'</span>), </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        inE(<span class="string">'created'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    .inV()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    .path()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    .by(<span class="string">'name'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    .by(label)</span></pre></td></tr></table></figure><p> JanusGraph这三类边都是存在的，按照优先级，返回了“implements”出边和邻接点。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按优先级寻找到顶点“HugeGraph”的以下边和邻接点，找到一个就停止（调换了示例1中的1和2的顺序）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、“supports”出边和邻接点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2、“implements”出边和邻接点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3、“created”入边和邻接点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:HugeGraph'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .coalesce(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    outE(<span class="string">'supports'</span>), </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    outE(<span class="string">'implements'</span>), </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    inE(<span class="string">'created'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    .inV()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    .path()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    .by(<span class="string">'name'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    .by(label)</span></pre></td></tr></table></figure><p> 这次由于“supports”放在了“implements”的前面，所以返回了“supports”出边和邻接点。 </p><h4 id="16-2-2、-optional"><a href="#16-2-2、-optional" class="headerlink" title="16.2.2、 optional()"></a>16.2.2、 <code>optional()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找顶点"linary"的“created”出顶点，如果没有就返回"linary"自己</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'linary'</span>).optional(out(<span class="string">'created'</span>))</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找顶点"linary"的“knows”出顶点，如果没有就返回"linary"自己</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'linary'</span>).optional(out(<span class="string">'knows'</span>))</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找每个“person”顶点的出“knows”顶点，如果存在，然后以出“knows”顶点为起点，继续寻找其出“created”顶点，最后打印路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .optional(out(<span class="string">'knows'</span>).optional(out(<span class="string">'created'</span>)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .path()</span></pre></td></tr></table></figure><p> 结果中的后面四个顶点因为没有出“knows”顶点，所以在第一步返回了自身后就停止了。 </p><h4 id="16-2-3、-union"><a href="#16-2-3、-union" class="headerlink" title="16.2.3、 union()"></a>16.2.3、 <code>union()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找顶点“linary”的出“created”顶点，邻接“knows”顶点，并将结果合并</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'linary'</span>).union(out(<span class="string">'created'</span>), both(<span class="string">'knows'</span>)).path()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找顶点“HugeGraph”的入“created”顶点（创作者），出“implements”和出“supports”顶点，并将结果合并</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:HugeGraph'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .union(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    __.in(<span class="string">'created'</span>), </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        out(<span class="string">'implements'</span>), </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    out(<span class="string">'supports'</span>), </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    out(<span class="string">'contains'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    .path()</span></pre></td></tr></table></figure><h2 id="17-结果聚集与展开"><a href="#17-结果聚集与展开" class="headerlink" title="17.结果聚集与展开"></a>17.结果聚集与展开</h2><h3 id="17-1、说明"><a href="#17-1、说明" class="headerlink" title="17.1、说明"></a>17.1、说明</h3><p>Gremlin在路径游走的时候，可以将某一步的所有结果收集到一个集合里面（我们称之为结果聚集），以备在后续步骤中使用；此外还可在需要的时候将聚集的结果展开。</p><p>下面讲解实现上述功能的具体Step：</p><p>aggregate(): 聚集路径中指定步骤的所有结果，通过aggregate(label)对任意步骤打上标签，在此之前的步骤的结果均会被收集到此标签所代表的集合中（但并不会影响路径的游走），可配合by及cap一起使用，通过cap(label)来获取该结果集合，此外还可通过select(label)或without(label)等其它方式读取。</p><ul><li><p>store(): 类似aggregate()，只是以Lazy的方式来收集。</p></li><li><p>unfold(): 将集合展开平铺，路径将扩张。</p></li><li><p>fold(): 将多个元素折叠为一个集合，路径将收缩。</p></li></ul><h3 id="17-2、实例讲解"><a href="#17-2、实例讲解" class="headerlink" title="17.2、实例讲解"></a>17.2、实例讲解</h3><h4 id="17-2-1、-aggregate-：聚集路径中的结果"><a href="#17-2-1、-aggregate-：聚集路径中的结果" class="headerlink" title="17.2.1、 aggregate()：聚集路径中的结果"></a>17.2.1、 <code>aggregate()</code>：聚集路径中的结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收集第1步的结果到集合'x'中</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：不影响后续结果</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'2:HugeGraph'</span>).out().aggregate(<span class="string">'x'</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收集第1步的结果到集合'x'中</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并通过cap取出结果</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与示例1比较，结果的层次更深了</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'2:HugeGraph'</span>).out()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .aggregate(<span class="string">'x'</span>).cap(<span class="string">'x'</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过by()来指定聚集的维度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'2:HugeGraph'</span>).out()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .aggregate(<span class="string">'x'</span>).by(<span class="string">'name'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .cap(<span class="string">'x'</span>)</span></pre></td></tr></table></figure><h4 id="17-2-2、-store-：以Lazy的方式来收集结果"><a href="#17-2-2、-store-：以Lazy的方式来收集结果" class="headerlink" title="17.2.2、 store()：以Lazy的方式来收集结果"></a>17.2.2、 <code>store()</code>：以Lazy的方式来收集结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以Lazy方式收集，后续步骤使用limit限制时，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路径中取到第2个结果时将会停止，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因此集合中有2个元素。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V().store(<span class="string">'x'</span>).by(<span class="string">'name'</span>).limit(<span class="number">1</span>).cap(<span class="string">'x'</span>)</span></pre></td></tr></table></figure><h4 id="17-2-3、-unfold-：以把集合展开、平铺"><a href="#17-2-3、-unfold-：以把集合展开、平铺" class="headerlink" title="17.2.3、 unfold()：以把集合展开、平铺"></a>17.2.3、 <code>unfold()</code>：以把集合展开、平铺</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将集合‘x’展开(层级变少了)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'2:HugeGraph'</span>).out()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .aggregate(<span class="string">'x'</span>).by(<span class="string">'name'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .cap(<span class="string">'x'</span>).unfold()</span></pre></td></tr></table></figure><h4 id="17-2-4、-fold-：将元素折叠为集合"><a href="#17-2-4、-fold-：将元素折叠为集合" class="headerlink" title="17.2.4、 fold()：将元素折叠为集合"></a>17.2.4、 <code>fold()</code>：将元素折叠为集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将属性折叠起来(层级变深)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'2:HugeGraph'</span>).out()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .values(<span class="string">'name'</span>).fold()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计所有'name'属性的长度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中通过lambuda表达式累加字符串长度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'2:HugeGraph'</span>).out().values(<span class="string">'name'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .fold(<span class="number">0</span>) &#123;a,b -&gt; a + b.length()&#125;</span></pre></td></tr></table></figure><h3 id="17-3、综合运用"><a href="#17-3、综合运用" class="headerlink" title="17.3、综合运用"></a>17.3、综合运用</h3><p>17.3.1、 查询一个软件的同类别软件，但不包括自身在内 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询与HugeGraph类似支持Gremlin语言的软件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 但不包含自身和一步邻居</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较：请看看去除where语句的效果</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'2:HugeGraph'</span>).aggregate(<span class="string">'x'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .out().aggregate(<span class="string">'x'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .out().in()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    .where(without(<span class="string">'x'</span>))</span></pre></td></tr></table></figure><h4 id="17-3-2、-查询2度之内的所有邻居的名称"><a href="#17-3-2、-查询2度之内的所有邻居的名称" class="headerlink" title="17.3.2、 查询2度之内的所有邻居的名称"></a>17.3.2、 查询2度之内的所有邻居的名称</h4><p>// 查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">询与HugeGraph的两度OUT邻居</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并收集这些到‘a’集合里面，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最终以‘name’属性展示其邻居</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'2:HugeGraph'</span>).out().aggregate(<span class="string">'a'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .out().aggregate(<span class="string">'a'</span>).cap(<span class="string">'a'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .unfold().values(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><h4 id="17-3-3、-查询由多人合作的软件及其各作者的名称"><a href="#17-3-3、-查询由多人合作的软件及其各作者的名称" class="headerlink" title="17.3.3、 查询由多人合作的软件及其各作者的名称"></a>17.3.3、 查询由多人合作的软件及其各作者的名称</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有由3个以上作者完成的软件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并显示它的名称及其作者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V().as(<span class="string">'software'</span>, <span class="string">'authors'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .where(__.in(<span class="string">'created'</span>).count().is(gte(<span class="number">3</span>)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .select(<span class="string">'software'</span>, <span class="string">'authors'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .by(<span class="string">'name'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    .by(__.in(<span class="string">'created'</span>).values(<span class="string">'name'</span>).fold())</span></pre></td></tr></table></figure><h2 id="18-模式匹配"><a href="#18-模式匹配" class="headerlink" title="18.模式匹配"></a>18.模式匹配</h2><h3 id="18-1、说明"><a href="#18-1、说明" class="headerlink" title="18.1、说明"></a>18.1、说明</h3><p>Gremlin中的match()语句为图查询提供了一种基于“模式匹配”的方式，以便用更具描述性的方式进行图查询。match()语句通过多个模式片段traversal fragments来进行模式匹配。这些traversal fragments中会定义一些变量，只有满足所有用变量表示的约束的对象才能够通过，并被放到一个Map&lt;String, Object&gt;中，其中map的key为变量名（label），value为顶点、边、路径或者属性。match()语句的格式为：match(Traversal…)。其中可以有任意多个Traversal，每一个Traversal就是一个“匹配模式”traversal fragment。</p><p>match()语句中的“模式”通过MatchAlgorithm来选择匹配顺序，默认的MatchAlgorithm是CountMatchAlgorithm。CountMatchAlgorithm根据过滤强度动态调整“模式匹配”的执行计划（最能够减少规模的“模式”优先匹配），从而优化执行减少资源消耗。因此，当图的规模比较大且用户不知道满足特定模式的数据规模时，使用match()可以自动进行优化，减小操作规模。另外，对于一些图查询场景，相较于单路径遍历，match()语句的“模式匹配”更容易表达需求。</p><h3 id="18-2、实例说明"><a href="#18-2、实例说明" class="headerlink" title="18.2、实例说明"></a>18.2、实例说明</h3><p> <code>match()</code>语句通过模式匹配生成<code>map</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对每一个顶点，用以下模式去匹配，满足则生成一个map&lt;String, Object&gt;，不满足则过滤掉</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模式1：“a”对应当前顶点，且创建了软件“HugeGraph”</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模式2：“b”对应顶点软件“HugeGraph”</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模式3：“c”对应创建软件“HugeGraph”的年龄为29的person顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">g.V().match(__.as(<span class="string">'a'</span>).out(<span class="string">'created'</span>).has(<span class="string">'name'</span>, <span class="string">'HugeGraph'</span>).as(<span class="string">'b'</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            __.as(<span class="string">'b'</span>).in(<span class="string">'created'</span>).has(<span class="string">'age'</span>, <span class="number">29</span>).as(<span class="string">'c'</span>))</span></pre></td></tr></table></figure><p> <code>match()</code>语句可以与<code>select()</code>语句配合使用，从<code>Map</code>中选取部分结果 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对每一个顶点，用以下模式去匹配，满足则生成一个map&lt;String, Object&gt;，不满足则过滤掉</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模式1：“a”对应当前顶点，且创建了软件“HugeGraph”</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模式2：“b”对应顶点软件“HugeGraph”</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模式3：“c”对应创建软件“HugeGraph”的年龄为29的person顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并选取map中的“a"和”c"，对应的对象以”name“属性的值代替</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">g.V().match(__.as(<span class="string">'a'</span>).out(<span class="string">'created'</span>).has(<span class="string">'name'</span>, <span class="string">'HugeGraph'</span>).as(<span class="string">'b'</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            __.as(<span class="string">'b'</span>).in(<span class="string">'created'</span>).has(<span class="string">'age'</span>, <span class="number">29</span>).as(<span class="string">'c'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">     .select(<span class="string">'a'</span>, <span class="string">'c'</span>).by(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><p> <code>match()</code>语句可以与<code>where()</code>语句配合使用，过滤结果 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对每一个顶点，用以下模式去匹配，满足则生成一个map&lt;String, Object&gt;，不满足则过滤掉</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模式1：“a”对应当前顶点，且创建了软件“HugeGraph”</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模式2：“b”对应顶点软件“HugeGraph”</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模式3：“c”对应创建软件“HugeGraph”的年龄为29的person顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模式4：”a“和”c“对应的对象不相等</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并选取map中的“a"和”c"，对应的对象以”name“属性的值代替</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">g.V().match(__.as(<span class="string">'a'</span>).out(<span class="string">'created'</span>).has(<span class="string">'name'</span>, <span class="string">'HugeGraph'</span>).as(<span class="string">'b'</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            __.as(<span class="string">'b'</span>).in(<span class="string">'created'</span>).has(<span class="string">'age'</span>, <span class="number">29</span>).as(<span class="string">'c'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">     .where(<span class="string">'a'</span>, neq(<span class="string">'c'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">     .select(<span class="string">'a'</span>, <span class="string">'c'</span>).by(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><p> <code>match()</code>语句中可以使用外部的label </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对每一个顶点打标签”a“，"a"经过一条OUT方向的”knows“边到达的顶点打标签”b“</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对”b“中的每一个顶点用以下模式去匹配，满足则生成一个map&lt;String, Object&gt;，不满足则过滤掉</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模式1：”b“通过一条OUT方向的”created“边到达顶点”c“</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模式2：”c“不能通过一条IN方向的”created“边到达”a“</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选取map中的“a"，”b“，”c"，对应的对象以”name“属性的值代替</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">g.V().as(<span class="string">'a'</span>).out(<span class="string">'knows'</span>).as(<span class="string">'b'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"> .match(__.as(<span class="string">'b'</span>).out(<span class="string">'created'</span>).as(<span class="string">'c'</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        __.not(__.as(<span class="string">'c'</span>).in(<span class="string">'created'</span>).as(<span class="string">'a'</span>)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"> .select(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>).by(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><blockquote><p> 注意<code>match(__.as(&#39;b&#39;).out(&#39;created&#39;).as(&#39;c&#39;)</code>中的<code>__.as(b)</code>是读取label标识的对象，<code>as(&#39;c&#39;)</code>是为新的对象打上label标识 </p></blockquote><h2 id="19-随机过滤与注入"><a href="#19-随机过滤与注入" class="headerlink" title="19.随机过滤与注入"></a>19.随机过滤与注入</h2><h3 id="19-1、随机过滤说明"><a href="#19-1、随机过滤说明" class="headerlink" title="19.1、随机过滤说明"></a>19.1、随机过滤说明</h3><p>Gremlin支持对遍历器（traversal）上的结果进行采样或者做随机过滤。</p><ul><li>sample: 接受一个整数值，从前一步的遍历器中采样（随机）出最多指定数目的结果；</li><li>coin: 字面意思是抛硬币过滤，接受一个浮点值，该浮点值表示硬币出现正面的概率。coin Step 对前一步的遍历器中的每个元素都抛一次硬币，出现正面则可以通过，反面则被拦截。</li></ul><blockquote><p>sampleStep后能接上byStep，能以指定的属性为判断依据进行随机过滤。</p></blockquote><h3 id="19-2、注入说明"><a href="#19-2、注入说明" class="headerlink" title="19.2、注入说明"></a>19.2、注入说明</h3><p>Gremlin允许在遍历器中注入一些默认值或自定义值，比如在分支 Step 中给 else 路径的元素一个默认值，又或者在遍历器过程中人为地加上一些额外的元素。</p><p>Inject Step</p><ul><li>constant: 通常用在choose或coalesceStep中做辅助输出，为那些不满足条件的元素提供一个默认值；</li><li>inject: 能够在流（遍历器）的任何位置注入与当前遍历器同输出类型的对象，当然，也可以作为流的起始 Step 产生数据；</li></ul><blockquote><p>inject只是在查询过程中添加一些额外的元素，并没有把数据真正地插入到图中</p></blockquote><h3 id="19-3、实例讲解"><a href="#19-3、实例讲解" class="headerlink" title="19.3、实例讲解"></a>19.3、实例讲解</h3><h4 id="19-3-1、-sample"><a href="#19-3-1、-sample" class="headerlink" title="19.3.1、 sample()"></a>19.3.1、 <code>sample()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从所有顶点的出边中随机选择2条</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().outE().sample(<span class="number">2</span>)</span></pre></td></tr></table></figure><blockquote><p> 由于<code>sample</code>是随机采样，所以运行结果每次都可能不一样。另外，<code>sample(n)</code>表示最多采样<code>n</code>个，如果上一步不够<code>n</code>个元素自然结果是会小于<code>n</code>的。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从所以顶点的“name”属性中随机选取3个</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().values(<span class="string">'name'</span>).sample(<span class="number">3</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从所有的“person”中根据“age”随机选择3个</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).sample(<span class="number">3</span>).by(<span class="string">'age'</span>)</span></pre></td></tr></table></figure><p> 与<code>local</code>联合使用做随机漫游（从某个顶点出发，随机选一条边，走到边上的邻接点；再以该点为起点，继续随机选择边，走到邻接点…） </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//  从顶点“HugeGraph”出发做3次随机漫游</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:HugeGraph'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .repeat(local(bothE().sample(<span class="number">1</span>).otherV()))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .times(<span class="number">3</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .path()</span></pre></td></tr></table></figure><h4 id="19-3-2、-coin"><a href="#19-3-2、-coin" class="headerlink" title="19.3.2、 coin()"></a>19.3.2、 <code>coin()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个顶点按0.5的概率过滤</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().coin(<span class="number">0.5</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个顶点按0.0的概率过滤</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().coin(<span class="number">0.0</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个顶点按1.0的概率过滤</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().coin(<span class="number">1.0</span>).count()</span></pre></td></tr></table></figure><blockquote><p> 避免输出太长，加上<code>count</code>。 </p></blockquote><h4 id="19-3-3、-constant"><a href="#19-3-3、-constant" class="headerlink" title="19.3.3、 constant()"></a>19.3.3、 <code>constant()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出所有“person”类顶点的“name”属性，否则输出“inhuman”（非人类）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().choose(hasLabel(<span class="string">'person'</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">             values(<span class="string">'name'</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">             constant(<span class="string">'inhuman'</span>))</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与示例1功能相同，使用“coalesce”Step 实现</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().coalesce(hasLabel(<span class="string">'person'</span>).values(<span class="string">'name'</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">               constant(<span class="string">'inhuman'</span>))</span></pre></td></tr></table></figure><h4 id="19-3-4、-inject"><a href="#19-3-4、-inject" class="headerlink" title="19.3.4、 inject()"></a>19.3.4、 <code>inject()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给顶点“HugeGraph”的作者添加一个叫“Tom”的人</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:HugeGraph'</span>).in(<span class="string">'created'</span>).values(<span class="string">'name'</span>).inject(<span class="string">'Tom'</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在示例1的基础上计算每个元素的长度（“name”属性值的长度）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:HugeGraph'</span>).in(<span class="string">'created'</span>).values(<span class="string">'name'</span>).inject(<span class="string">'Tom'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .map &#123;it.get().length()&#125;</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在示例2的基础上计算走过的路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:HugeGraph'</span>).in(<span class="string">'created'</span>).values(<span class="string">'name'</span>).inject(<span class="string">'Tom'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .map &#123;it.get().length()&#125;.path()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用inject创建出两个元素（顶点的id），并使用该元素作为id获取顶点及其属性“name”</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">inject(<span class="string">'javeme'</span>, <span class="string">'linary'</span>, <span class="string">'zhoney'</span>).map &#123;g.V(it.get()).next()&#125;.values(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用inject创建出一个“person”（顶点label），并使用该元素作为label获取顶点及其属性“name”</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">inject(<span class="string">'person'</span>).flatMap &#123;g.V().hasLabel(it.get())&#125;.values(<span class="string">'name'</span>)</span></pre></td></tr></table></figure><h2 id="20-结果存取口袋sack"><a href="#20-结果存取口袋sack" class="headerlink" title="20.结果存取口袋sack"></a>20.结果存取口袋sack</h2><h3 id="20-1、说明"><a href="#20-1、说明" class="headerlink" title="20.1、说明"></a>20.1、说明</h3><p>Gremlin在路径遍历的时候，可以将中间结果存放到一个叫口袋（sack）的结构里面，以备在后续步骤中使用；此外在放入数据到口袋的时候，还可以做一些灵活的操作比如：分裂（split）、合并（merge）等。sack相关step属于Gremlin语言里面的高级操作，在处理较为复杂的任务时可以灵活的实现一些特殊功能。</p><p>下面讲解实现上述功能的具体Step：</p><ul><li>withSack(): 创建一个口袋，并给定一个初始结构，比如可以是一个返回Map或者随机数的lambda函数，也可以是一个对象或常数；另外还可以提供lambda分裂函数，以指定当traverser分裂时的行为，比如进行clone操作。</li><li>sack(): 将数据放入口袋，或者从口袋取出数据。当传入lambda合并函数作为参数时，可指定放入口袋的行为如何执行；当不传入参数时表示读取口袋中的内容。</li></ul><h3 id="20-2、实例讲解"><a href="#20-2、实例讲解" class="headerlink" title="20.2、实例讲解"></a>20.2、实例讲解</h3><p> <code>withSack()…sack()</code>： 利用口袋来存取结果 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个包含常数1的口袋，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并且在最终取出口袋中的值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.withSack(<span class="number">1</span>).V().sack()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个包含随机常数的口袋，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并且在最终取出口袋中的值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.withSack&#123;<span class="keyword">new</span> Random().nextFloat()&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">.V().sack()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过sum求和的方式把数据放入口袋</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.withSack(<span class="number">0</span>).V()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .repeat(outE().sack(sum).by(<span class="string">'weight'</span>).inV())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .times(<span class="number">3</span>).sack()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//  通过以下gremlin查看路径及其权重： </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.withSack(<span class="number">0</span>).V()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .repeat(outE().sack(sum).by(<span class="string">'weight'</span>).inV())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .times(<span class="number">3</span>).path().by().by(<span class="string">'weigh'</span>)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过lambda函数来指定放入口袋的行为</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：提供的初始值为Map类型，而且</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当traverser分裂时会拷贝Map</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.withSack&#123;[:]&#125;&#123;it.clone()&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">.V().out().out().dedup()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .sack&#123;m,v -&gt; m[v.value(<span class="string">'name'</span>)] = v.value(<span class="string">'lang'</span>); m&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">.sack()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平均获取口袋中的值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.withSack(<span class="number">1.0</span>).V(<span class="string">'javeme'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .out(<span class="string">'knows'</span>).out(<span class="string">'created'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .barrier(normSack).sack()</span></pre></td></tr></table></figure><h3 id="20-3、综合应用"><a href="#20-3、综合应用" class="headerlink" title="20.3、综合应用"></a>20.3、综合应用</h3><h4 id="20-3-1、-获取路径并计算路径权重之和"><a href="#20-3-1、-获取路径并计算路径权重之和" class="headerlink" title="20.3.1、 获取路径并计算路径权重之和"></a>20.3.1、 获取路径并计算路径权重之和</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取路径的同时通过sack(sum)计算权重之和</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最终通过select把权重和路径选取出来</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.withSack(<span class="number">0</span>).V()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .repeat(outE().sack(sum).by(<span class="string">'weight'</span>).inV().as(<span class="string">'p'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .times(<span class="number">3</span>).sack().as(<span class="string">'w'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .select(<span class="string">'w'</span>, <span class="string">'p'</span>).by().by&#123;p-&gt;p.toString()&#125;.limit(<span class="number">3</span>)</span></pre></td></tr></table></figure><h4 id="20-3-2、-获取路径并根据路径权重之和排序"><a href="#20-3-2、-获取路径并根据路径权重之和排序" class="headerlink" title="20.3.2、 获取路径并根据路径权重之和排序"></a>20.3.2、 获取路径并根据路径权重之和排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取路径的同时通过sack(sum)计算权重之和</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最终通过order().by(sack())根据总权重排序</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.withSack(<span class="number">0</span>).V()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .repeat(outE().sack(sum).by(<span class="string">'weight'</span>).inV())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .times(<span class="number">3</span>).order().by(sack(),decr)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .path().limit(<span class="number">3</span>)</span></pre></td></tr></table></figure><h2 id="21-遍历栅栏barrier"><a href="#21-遍历栅栏barrier" class="headerlink" title="21.遍历栅栏barrier"></a>21.遍历栅栏barrier</h2><h3 id="21-1、说明"><a href="#21-1、说明" class="headerlink" title="21.1、说明"></a>21.1、说明</h3><p>Gremlin在路径遍历的时候，可以将栅栏barrier插入到懒加载的遍历流水线中，以使得barrier之前的步骤都执行完成之后再继续往下执行。barrier主要有2个好处：1、可以强制改变深度优先搜索为广度优先搜索，2、由于通过层的bulking模式可以优化大量重复的数据访问。</p><p>下面讲解实现上述功能的具体Step：</p><ul><li>barrier(): 在某个位置插入一个栅栏，以强制该位置之前的步骤必须都执行完成才可以继续往后执行，比如g.V().both().barrier().both()只有在第一个both()全部完成之后才会执行第二个both()。</li></ul><h3 id="21-2、实例讲解"><a href="#21-2、实例讲解" class="headerlink" title="21.2、实例讲解"></a>21.2、实例讲解</h3><h4 id="21-2-1、-遍历时设置栅栏"><a href="#21-2-1、-遍历时设置栅栏" class="headerlink" title="21.2.1、 遍历时设置栅栏"></a>21.2.1、 遍历时设置栅栏</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有顶点打印出来</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印完一轮之后再打印一轮</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">def list=[]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V().sideEffect&#123;list.add(<span class="string">"first: "</span>+it)&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">     .barrier()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">     .sideEffect&#123;list.add(<span class="string">"second: "</span>+it)&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">     .iterate()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">list</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印first后打印second，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直到一轮所有的顶点都完成</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">def list=[]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V().sideEffect&#123;list.add(<span class="string">"first: "</span>+it)&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">     .sideEffect&#123;list.add(<span class="string">"second: "</span>+it)&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">     .iterate()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">list</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁用自动barrier策略</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g = g.withoutStrategies(LazyBarrierStrategy)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"> .both().barrier()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"> .both().barrier()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"> .both().barrier()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"> .both().barrier()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"> .both().barrier()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"> .groupCount()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"> .order(local).by(values, decr)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过lambda函数来指定放入口袋的行为</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：提供的初始值为Map类型，而且</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当traverser分裂时会拷贝Map</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g = g.withoutStrategies(LazyBarrierStrategy)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">g.V()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"> .both()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"> .both()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"> .both()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"> .both()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"> .both()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"> .groupCount()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"> .order(local).by(values, decr)</span></pre></td></tr></table></figure><blockquote><p> 注意：LazyBarrierStrategy是默认策略，该策略会在合适的地方插入barrier，因此这里先禁用了该策略。 </p></blockquote><h4 id="22-2-2、-barrier-相关Step："><a href="#22-2-2、-barrier-相关Step：" class="headerlink" title="22.2.2、 barrier()相关Step："></a>22.2.2、 <code>barrier()</code>相关Step：</h4><p>事实上除了可显示的插入barrier栅栏外，还有不少Step会隐式插入barrier，包括 order(), sample(), dedup(), aggregate(), fold(), count(), sum(), max(), min(), group(), groupCount(), cap()等。</p><h3 id="21-3、综合运用"><a href="#21-3、综合运用" class="headerlink" title="21.3、综合运用"></a>21.3、综合运用</h3><h4 id="21-3-1、-计算特征向量中心性（Eigenvector-Centrality）"><a href="#21-3-1、-计算特征向量中心性（Eigenvector-Centrality）" class="headerlink" title="21.3.1、 计算特征向量中心性（Eigenvector Centrality）"></a>21.3.1、 计算特征向量中心性（Eigenvector Centrality）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用隐式barrier计算特征向量中心性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包括groupCount、cap，按照降序排序</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V().repeat(both().groupCount(<span class="string">'m'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .times(<span class="number">5</span>).cap(<span class="string">'m'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .order(local).by(values, decr)</span></pre></td></tr></table></figure><h2 id="22-局部操作local"><a href="#22-局部操作local" class="headerlink" title="22.局部操作local"></a>22.局部操作local</h2><h3 id="22-1、说明"><a href="#22-1、说明" class="headerlink" title="22.1、说明"></a>22.1、说明</h3><p> 通过Gremlin进行图遍历通常是当前step处理前一step传递过来的对象流。很多操作是针对传递过来的对象流中的全部对象进行操作，但也有很多时候需要针对对象流中的单个对象而非对象流中的全部对象进行一些操作。这种对单个对象的局部操作，可以使用local()语句实现。</p><p>另外，有一些step默认的操作是针对对象流中的全部对象，但也可以通过参数来改变默认操作，允许针对对象流中的单个对象进行操作，包括count()，max()，mean()，min()，sum()，order()，tail()，limit()，range()，sample()，skip()和dedup()等。</p><h3 id="22-2、实例说明"><a href="#22-2、实例说明" class="headerlink" title="22.2、实例说明"></a>22.2、实例说明</h3><h4 id="22-2-1、local的作用说明"><a href="#22-2-1、local的作用说明" class="headerlink" title="22.2.1、local的作用说明"></a>22.2.1、local的作用说明</h4><p>是否使用<code>local()</code>的区别可以参见如下示意图： </p><p><img src="4.png" srcset="/img/loading.gif" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用local()</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).as(<span class="string">'person'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .properties(<span class="string">'age'</span>).order().by(value).limit(<span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .value().as(<span class="string">'age'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .select(<span class="string">'person'</span>,<span class="string">'age'</span>).by(<span class="string">'name'</span>).by()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用local()</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).as(<span class="string">'person'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .local(properties(<span class="string">'age'</span>).order().by(value).limit(<span class="number">2</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .value().as(<span class="string">'age'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .select(<span class="string">'person'</span>,<span class="string">'age'</span>).by(<span class="string">'name'</span>).by()</span></pre></td></tr></table></figure><h4 id="22-2-2、以参数的形式指定局部操作"><a href="#22-2-2、以参数的形式指定局部操作" class="headerlink" title="22.2.2、以参数的形式指定局部操作"></a>22.2.2、以参数的形式指定局部操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询软件HugeGraph的属性Map</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'software'</span>).has(<span class="string">'name'</span>, <span class="string">'HugeGraph'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .propertyMap()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询软件HugeGraph的属性个数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'software'</span>).has(<span class="string">'name'</span>, <span class="string">'HugeGraph'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .propertyMap().count(local)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数目最多的顶点类型的顶点数目</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().groupCount().by(label).select(values).max(local)</span></pre></td></tr></table></figure><blockquote><p> <code>min()</code>、<code>mean()</code>、<code>sum()</code>等与<code>max()</code>使用local参数的方法基本一致，不再赘述 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有顶点的属性列表中的第一个属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().valueMap().limit(local, <span class="number">1</span>)</span></pre></td></tr></table></figure><blockquote><p> <code>tail()</code>、<code>range()</code>、<code>skip()</code>与<code>limit()</code>使用local参数的方法基本一致，不再赘述 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有顶点一步邻居中所有的software</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().both().group().by(label).select(<span class="string">'software'</span>).dedup(local)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有顶点按类型计数并按数目由多到少排序</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().groupCount().by(label).order(local).by(values, decr)</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有顶点作为一个集合，从中采样2个</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().fold().sample(local,<span class="number">2</span>)</span></pre></td></tr></table></figure><h2 id="23-遍历终止terminal"><a href="#23-遍历终止terminal" class="headerlink" title="23.遍历终止terminal"></a>23.遍历终止terminal</h2><h3 id="23-1、说明"><a href="#23-1、说明" class="headerlink" title="23.1、说明"></a>23.1、说明</h3><p>Gremlin 中有一类特殊的操作，它能够终止遍历器的“遍历”行为，使其执行并返回结果。在这里要强调的一点：原生的 Gremlin 语句通常都是用遍历器连接起来的，但其实这些连接的过程并不会执行 Gremlin 语句，只有走到了terminalStep 时才会执行。这个模式类似于 Spark 中对RDD的map和action操作。</p><ul><li><p>hasNext: 判断遍历器是否含有元素（结果），返回布尔值；</p></li><li><p>next: 不传参数时获取遍历器的下一个元素，也可以传入一个整数 n，则获取后面 n 个元素；</p></li><li><p>tryNext: hasNext和next的结合版，返回一个Optional对象，如果有结果还需要调用get()方法才能拿到；</p></li><li><p>toList: 将所有的元素放到一个List中返回；</p></li><li><p>toSet: 将所有的元素放到一个Set中返回，会去除重复元素；</p></li><li><p>toBulkSet: 将所有的元素放到一个能排序的List中返回，重复元素也会保留；</p></li><li><p>fill: 传入一个集合对象，将所有的元素放入该集合并返回，其实toList、toSet和toBulkSet就是通过fillStep实现的；</p></li><li><p>iterate: 这个 Step 在终止操作里面有点特殊，它并不完全符合终止操作的定义。它会在内部迭代完整个遍历器但是不返回结果。</p></li></ul><p>前面我们介绍了那么多的 Step 很多都没有加terminalStep 啊，为什么也能返回结果呢？其实这是 Tinkerpop 的 Gremlin 解析引擎对遍历器对象调用了一个IteratorUtils.asList()方法，又调用了它内部的fill()方法（注意：不是上面讲到的fill()Step）。</p><h3 id="23-2、实例讲解"><a href="#23-2、实例讲解" class="headerlink" title="23.2、实例讲解"></a>23.2、实例讲解</h3><h4 id="23-2-1、-hasNext"><a href="#23-2-1、-hasNext" class="headerlink" title="23.2.1、 hasNext()"></a>23.2.1、 <code>hasNext()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断顶点“linary”是否包含“created”出顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'linary'</span>).out(<span class="string">'created'</span>).hasNext()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断顶点“linary”是否包含“knows”出顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'linary'</span>).out(<span class="string">'knows'</span>).hasNext()</span></pre></td></tr></table></figure><h4 id="23-2-2、-next"><a href="#23-2-2、-next" class="headerlink" title="23.2.2、 next()"></a>23.2.2、 <code>next()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取顶点“javeme”的“knows”出顶点集合的下一个（第1个）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'javeme'</span>).out(<span class="string">'knows'</span>).next()</span></pre></td></tr></table></figure><blockquote><p> <code>g.V(&#39;javeme&#39;).out(&#39;knows&#39;)</code>返回的是一个遍历器（迭代器），每次执行这句话实际上都是获取的迭代器的第一个元素，那如果想获取第二个元素该怎么写呢？很简单，执行两次<code>next()</code>即可，但是这里的前提条件是遍历器中确实存在多个元素。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取顶点“javeme”的“knows”出顶点集合的下一个（第2个）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">it = g.V(<span class="string">'javeme'</span>).out(<span class="string">'knows'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">it.next()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">it.next()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取顶点“javeme”的“knows”出顶点集合的前两个</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'javeme'</span>).out(<span class="string">'knows'</span>).next(<span class="number">2</span>)</span></pre></td></tr></table></figure><blockquote><p> <code>next()</code>与<code>next(n)</code>使用中有一点小小的区别，就是当没有元素或者没有足够多的元素时，执行<code>next()</code>会报错，但是执行<code>next(n)</code>则是返回一个空集合（List）。 </p></blockquote><h4 id="23-2-3、-tryNext"><a href="#23-2-3、-tryNext" class="headerlink" title="23.2.3、 tryNext()"></a>23.2.3、 <code>tryNext()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 试图获取顶点“javeme”的“created”出顶点集合中的下一个</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'javeme'</span>).out(<span class="string">'created'</span>).tryNext()</span></pre></td></tr></table></figure><blockquote><p> 这里会发现结果与前面概述中说的有些不同。概述中说的是返回一个<code>Optional</code>对象，要获取<code>Optional</code>对象里的值是需要调用它的<code>get()</code>方法的，怎么这里直接就把值给返回了呢？大家先别着急，我们再看一个例子。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 试图获取顶点“javeme”的“created”入顶点集合中的下一个</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'javeme'</span>).in(<span class="string">'created'</span>).tryNext()</span></pre></td></tr></table></figure><blockquote><p>这里更加令人费解，没有“created”入顶点时竟然直接报错了，其实这是HugeGraph的实现中关于Optional的序列化所致。HugeGraph序列化Optional对象时会判断该对象内的值是否存在，如果存在则取出来序列化该值，否则填入一个null。详细代码见HugeGraphSONModule.java中关于OptionalSerializer的实现。</p></blockquote><p> 本文的重点在于学习<code>Gremlin</code>语法本身，下面给出上述两个示例的预期结果： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Optional[v[<span class="number">3</span>:HugeGraph]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Optional.empty</span></pre></td></tr></table></figure><h4 id="23-2-4、-toList"><a href="#23-2-4、-toList" class="headerlink" title="23.2.4、 toList()"></a>23.2.4、 <code>toList()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有“person”顶点的“created”出顶点集合，放入List中，允许包含重复结果</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).out(<span class="string">'created'</span>).toList()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有“person”顶点的“created”入顶点集合，放入List中，允许包含重复结果</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).in(<span class="string">'created'</span>).toList()</span></pre></td></tr></table></figure><blockquote><p> 结果与<code>next(n)</code>有些类似。 </p></blockquote><h4 id="23-2-5、-toSet"><a href="#23-2-5、-toSet" class="headerlink" title="23.2.5、 toSet()"></a>23.2.5、 <code>toSet()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有“person”顶点的“created”出顶点集合，放入Set中，不允许包含重复结果</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).out(<span class="string">'created'</span>).toSet()</span></pre></td></tr></table></figure><blockquote><p> 相比于<code>toList</code>，<code>toSet</code>去除了重复元素。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有“person”顶点的“created”入顶点集合，放入Set中，不允许包含重复结果</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).in(<span class="string">'created'</span>).toSet()</span></pre></td></tr></table></figure><h4 id="23-2-6、-toBulkSet"><a href="#23-2-6、-toBulkSet" class="headerlink" title="23.2.6、 toBulkSet()"></a>23.2.6、 <code>toBulkSet()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有“person”顶点的“created”出顶点集合，放入BulkSet中，允许包含重复结果，排序</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).out(<span class="string">'created'</span>).toBulkSet()</span></pre></td></tr></table></figure><blockquote><p> 所谓的<code>BulkSet</code>虽然名字上带有”Set”，但还是更像一个List，对比<code>toList</code>的结果，它实际上是把所有元素排了个序。 </p></blockquote><h4 id="23-2-7、-fill"><a href="#23-2-7、-fill" class="headerlink" title="23.2.7、 fill()"></a>23.2.7、 <code>fill()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个List，获取所有“person”顶点的“created”出顶点，并放入该List中</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">results = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).out(<span class="string">'created'</span>).fill(results)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">results</span></pre></td></tr></table></figure><h4 id="23-2-8、-iterate"><a href="#23-2-8、-iterate" class="headerlink" title="23.2.8、 iterate()"></a>23.2.8、 <code>iterate()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代所有“person”顶点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">it = g.V().hasLabel(<span class="string">'person'</span>).iterate()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">it.hasNext()</span></pre></td></tr></table></figure><blockquote><p> 调用了<code>iterate()</code>后遍历器内部的元素就已经全部迭代过了，所以再调用<code>hasNext()</code>返回false。 </p></blockquote><h2 id="24-转换操作map-flatMap"><a href="#24-转换操作map-flatMap" class="headerlink" title="24.转换操作map/flatMap"></a>24.转换操作map/flatMap</h2><h3 id="24-1、说明"><a href="#24-1、说明" class="headerlink" title="24.1、说明"></a>24.1、说明</h3><ul><li><p>map: 可以接受一个遍历器 Step 或 Lamda 表达式，将遍历器中的元素映射（转换）成另一个类型的某个对象（一对一），以便进行下一步处理；</p></li><li><p>flatMap: 可以接受一个遍历器 Step 或 Lamda 表达式，将遍历器中的元素映射（转换）成另一个类型的某个对象流或迭代器（一对多）。</p></li></ul><h3 id="24-2、操作实例"><a href="#24-2、操作实例" class="headerlink" title="24.2、操作实例"></a>24.2、操作实例</h3><h4 id="24-2-1、-map"><a href="#24-2-1、-map" class="headerlink" title="24.2.1、 map()"></a>24.2.1、 <code>map()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取顶点“3:HugeGraph”的入“created”顶点的“name”属性，其实可以理解为顶点对象转化成了属性值对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:HugeGraph'</span>).in(<span class="string">'created'</span>).map(values(<span class="string">'name'</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// g.V('3:HugeGraph').in('created').map &#123;it.get().value('name')&#125;</span></span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先获取顶点“3:HugeGraph”的入“created”顶点，再将每个顶点转化为出边（一条）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:HugeGraph'</span>).in(<span class="string">'created'</span>).map(outE())</span></pre></td></tr></table></figure><blockquote><p> 注意：顶点“javeme”其实是有三条边的，但是这里只打印出了一条。因为<code>map</code>Step是一对一的转换，要想获取所有的边可以使用<code>flatMap</code>。 </p></blockquote><h4 id="24-2-2、-flatMap"><a href="#24-2-2、-flatMap" class="headerlink" title="24.2.2、 flatMap()"></a>24.2.2、 <code>flatMap()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先获取顶点“3:HugeGraph”的入“created”顶点，再将每个顶点转化为出边（多条）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V(<span class="string">'3:HugeGraph'</span>).in(<span class="string">'created'</span>).flatMap(outE())</span></pre></td></tr></table></figure><blockquote><p> 注意：这一次就能打印出顶点“javeme”的全部三条边了。 </p></blockquote><h2 id="25-附加操作sideEffect"><a href="#25-附加操作sideEffect" class="headerlink" title="25.附加操作sideEffect"></a>25.附加操作sideEffect</h2><h3 id="25-1、说明"><a href="#25-1、说明" class="headerlink" title="25.1、说明"></a>25.1、说明</h3><p>Gremlin在路径遍历的时候，可以在路径中做一些额外的附加操作，这个附加操作不会改变上一步的结果，会原封不动的传递到下一步去。附加操作看起来就像透明的，但实际上可以将附加操作的处理结果存储到外部变量中去。</p><p>下面讲解实现上述功能的具体Step：</p><ul><li><p>sideEffect(): 在某个位置插入一个附加操作，以执行额外的操作，通常可与store、sack等配合使用。另外如下一些Step本质上也是sideEffect：</p><p>group(string)、groupCount(string)、subgraph(string)、aggregate(string)、inject(string)、profile(string)等。</p></li><li><p>withSideEffect()：绑定初始值到变量上，等价于sideEffect的效果。</p></li></ul><h3 id="25-2、实例讲解"><a href="#25-2、实例讲解" class="headerlink" title="25.2、实例讲解"></a>25.2、实例讲解</h3><h4 id="25-2-1、-sideEffect-：-附加操作"><a href="#25-2-1、-sideEffect-：-附加操作" class="headerlink" title="25.2.1、 sideEffect()： 附加操作"></a>25.2.1、 <code>sideEffect()</code>： 附加操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有顶点打印出来</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// sideEffect本身不影响结果</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">def list=[]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    .sideEffect&#123;list.add(<span class="string">"vertex:"</span>+it)&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">.toList()</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将sideEffect处理的结果打印出来</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">def list=[]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .sideEffect&#123;list.add(<span class="string">"vertex:"</span>+it)&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">.toList()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">list</span></pre></td></tr></table></figure><blockquote><p> 注意：Gremlin中的最后一行内容表示输出的结果 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将sideEffect结果存到变量中</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .sideEffect(outE().count().store(<span class="string">"o"</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .sideEffect(inE().count().store(<span class="string">"i"</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .cap(<span class="string">"o"</span>,<span class="string">"i"</span>)</span></pre></td></tr></table></figure><h4 id="25-2-2、-withSideEffect-：-绑定变量初始值"><a href="#25-2-2、-withSideEffect-：-绑定变量初始值" class="headerlink" title="25.2.2、 withSideEffect()： 绑定变量初始值"></a>25.2.2、 <code>withSideEffect()</code>： 绑定变量初始值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个变量以供后续条件判断中使用</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找javeme的共同作者，且名称在初始集合中</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">g.withSideEffect(<span class="string">'p'</span>,[<span class="string">'Linary Li'</span>,<span class="string">'Zhoney Zhang'</span>,<span class="string">'Tom'</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .V(<span class="string">'javeme'</span>).out(<span class="string">'created'</span>).in(<span class="string">'created'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .values(<span class="string">'name'</span>).where(within(<span class="string">'p'</span>))</span></pre></td></tr></table></figure><h3 id="25-3、综合运用"><a href="#25-3、综合运用" class="headerlink" title="25.3、综合运用"></a>25.3、综合运用</h3><h4 id="25-3-1、-计算度中心性（Degree-Centrality）"><a href="#25-3-1、-计算度中心性（Degree-Centrality）" class="headerlink" title="25.3.1、 计算度中心性（Degree Centrality）"></a>25.3.1、 计算度中心性（Degree Centrality）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用sideEffect计算3种度中心性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">g.V().group(<span class="string">'both'</span>).by().by(bothE().count())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    .group(<span class="string">'out'</span>).by().by(outE().count())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .group(<span class="string">'in'</span>).by().by(inE().count())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .cap(<span class="string">'both'</span>, <span class="string">'out'</span>, <span class="string">'in'</span>)</span></pre></td></tr></table></figure><h2 id="26-执行统计和分析"><a href="#26-执行统计和分析" class="headerlink" title="26.执行统计和分析"></a>26.执行统计和分析</h2><h3 id="26-1、说明"><a href="#26-1、说明" class="headerlink" title="26.1、说明"></a>26.1、说明</h3><p>Gremlin提供了两种语句来帮助用户对执行的查询语句进行统计和分析工作：</p><ul><li><p>explain()，详细描述原始的Gremlin语句在编译期是如何转变为最终要执行的step集合的</p></li><li><p>profile()，统计Gremlin语句执行过程中的每个step消耗的时间和通过的对象等统计信息</p></li></ul><p>TraversalStrategy是“遍历策略”，可以在编译期分析遍历（Traversal）的组成，并在遍历满足TraversalStrategy的条件时对遍历进行修改。这些修改往往都是为了能够更加高效的执行遍历。</p><p>遍历策略有5类：</p><ul><li><p>Decoration，应用程序级别的策略</p></li><li><p>Optimization，TinkerPop3级别的策略</p></li><li><p>Provider optimization，图数据库实现级别的策略</p></li><li><p>Finalization，遍历执行前的调整和清理策略</p></li><li><p>Verification，判断遍历是否合法的验证策略</p></li></ul><h3 id="26-2、实例讲解"><a href="#26-2、实例讲解" class="headerlink" title="26.2、实例讲解"></a>26.2、实例讲解</h3><h4 id="26-2-1、-explain"><a href="#26-2-1、-explain" class="headerlink" title="26.2.1、 explain()"></a>26.2.1、 <code>explain()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(<span class="string">'person'</span>).outE().identity().inV().count().is(gt(<span class="number">5</span>)).explain()</span></pre></td></tr></table></figure><p>结果中：</p><ul><li><p>original，表示Gremlin语句等价的最初的step列表</p></li><li><p>intermediate，表示original转化在TraversalStrategy作用下的转化过程</p></li></ul><blockquote><ul><li><p>strategy，表示作用于上一轮的step列表的TraversalStrategy</p></li><li><p>category，表示strategy中的TraversalStrategy所属的级别，参见说明部分</p></li><li><p>traversal，表示上一轮的step列表经过strategy中的TraversalStrategy处理之后的新的step列表</p></li></ul></blockquote><ul><li>final，表示经过所有TraversalStrategy处理后的最终要执行的step列表</li></ul><h4 id="26-2-2、-profile"><a href="#26-2-2、-profile" class="headerlink" title="26.2.2、 profile()"></a>26.2.2、 <code>profile()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">g.V().out(<span class="string">'created'</span>).profile()</span></pre></td></tr></table></figure><p>返回的结果中，metrics中每一条是一个执行的step，其中：</p><ul><li>name是step的名字，例如”HugeGraphStep(vertex,[])”</li><li>dur是step执行的时间，单位是毫秒</li><li>annotations中的percentDur是当前step消耗的时间在总的执行时间中的比例</li><li>counts中的traverserCount是当前step中的traverser的数目</li><li>counts中的elementCount是当前step中的element的数目</li></ul><blockquote><p>traverserCount和elementCount的区别在于： traverserCount是同一step中相同的对象合并之后的数目，对象相同是指当前的对象是一样的，并不代表对象的path等其他数据也相同；相同的对象合并为bulk，可以减少重复工作，提高效率。elementCount是同一step中所有对象展开bulk之后的数目之和，即未去重的对象数目。因此，traverserCount总是小于等于elementCount。</p></blockquote><p> <code>profile()</code>语句是一个“副作用”（side effect）语句，并非立刻执行。<code>profile()</code>语句还可以指定一个key，形式为<code>profile(String)</code>，在执行完要统计的Gremlin语句后，通过key获取统计信息。例如： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">t=g.V().out(<span class="string">'created'</span>).profile(<span class="string">'metrics'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">t.iterate()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">t.getSideEffects().get(<span class="string">'metrics'</span>)</span></pre></td></tr></table></figure><h2 id="27-Gremlin-Java-API"><a href="#27-Gremlin-Java-API" class="headerlink" title="27. Gremlin Java API"></a>27. Gremlin Java API</h2><h3 id="27-1、Maven配置"><a href="#27-1、Maven配置" class="headerlink" title="27.1、Maven配置"></a>27.1、Maven配置</h3><p>在Maven的pom.xml配置文件中增加如下引用:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.janusgraph<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>janusgraph-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.janusgraph<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>janusgraph-cql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.janusgraph<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>janusgraph-es<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tinkerpop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gremlin-driver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure><h3 id="27-2、配置JanusGraph配置文件janusgraph-cql-es-properties"><a href="#27-2、配置JanusGraph配置文件janusgraph-cql-es-properties" class="headerlink" title="27.2、配置JanusGraph配置文件janusgraph-cql-es.properties"></a>27.2、配置JanusGraph配置文件janusgraph-cql-es.properties</h3><p>janusgraph-cql-es.properties文件配置示例如下:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">gremlin.graph</span>=<span class="string">org.janusgraph.core.JanusGraphFactory</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">storage.backend</span>=<span class="string">cql</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">storage.hostname</span>=<span class="string">192.156.193.222</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">storage.cql.keyspace</span>=<span class="string">janusgraphdev</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="meta">index.search.backend</span>=<span class="string">elasticsearch</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="meta">index.search.hostname</span>=<span class="string">192.156.193.222</span></span></pre></td></tr></table></figure><h3 id="27-3、创建Spring-Bean文件JanusgraphBean-java"><a href="#27-3、创建Spring-Bean文件JanusgraphBean-java" class="headerlink" title="27.3、创建Spring Bean文件JanusgraphBean.java"></a>27.3、创建Spring Bean文件JanusgraphBean.java</h3><p>JanusgraphBean.java内容如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.esint.api.utils.PropertiesUtil;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.janusgraph.core.JanusGraph;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.janusgraph.core.JanusGraphFactory;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JanusgraphBean</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> String confFile = PropertiesUtil.getPropValue(<span class="string">"janusgraph.conf.file"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="function">JanusGraph <span class="title">client</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> JanusGraphFactory.open(confFile);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="27-4、一些Java使用JanusGraph的示例"><a href="#27-4、一些Java使用JanusGraph的示例" class="headerlink" title="27.4、一些Java使用JanusGraph的示例"></a>27.4、一些Java使用JanusGraph的示例</h3><h4 id="27-4-1、查询节点的周边的边与节点"><a href="#27-4-1、查询节点的周边的边与节点" class="headerlink" title="27.4.1、查询节点的周边的边与节点"></a>27.4.1、查询节点的周边的边与节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* 根据身份证号找到节点并且查询该节点的周边节点.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryVertexByIdCardTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    JanusGraph graph = JanusgraphBean.getJanusGraph();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    JanusGraphTransaction transaction = graph.newTransaction();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    GraphTraversalSource g = transaction.traversal();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    GraphTraversal&lt;Vertex, Path&gt; traversal = g.V()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        .has(<span class="string">"personId"</span>, <span class="string">"120221198209293016"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        .outE().inV().path()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        .by(__.valueMap().with(WithOptions.tokens))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        .by(__.valueMap().with(WithOptions.tokens));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> (traversal.hasNext()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        Path thisobj = traversal.next();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 分别截取图库查询返回结果中的三部分，左节点、边、右节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        Map&lt;String, List&gt; lv = thisobj.get(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        Map&lt;String, List&gt; relation = thisobj.get(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        Map&lt;String, List&gt; rv = thisobj.get(<span class="number">2</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        System.out.println(JSON.toJSONString(lv));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        System.out.println(JSON.toJSONString(relation));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        System.out.println(JSON.toJSONString(rv));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//关闭查询</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    g.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//关闭查询事务</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    transaction.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="27-4-2、查询节点"><a href="#27-4-2、查询节点" class="headerlink" title="27.4.2、查询节点"></a>27.4.2、查询节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* 如果节点不存在则创建节点并返回</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* <span class="doctag">@param</span> graph JanusGraph实例对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* <span class="doctag">@param</span> key   节点key</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* <span class="doctag">@param</span> value 节点value</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* <span class="doctag">@return</span> 节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vertex <span class="title">getVertex</span><span class="params">(String key, String value)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    JanusGraph graph = JanusgraphBean.getJanusGraph();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    JanusGraphTransaction transaction = graph.newTransaction();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    GraphTraversalSource g = transaction.traversal();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    Vertex v;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    GraphTraversal&lt;?, Vertex&gt; graphTraversal = graph.traversal().V().has(key, value);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (graphTraversal.hasNext()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        v = graphTraversal.next();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        v = graph.addVertex(<span class="string">"person"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        v.property(key, value);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> v;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="27-4-2、查询边"><a href="#27-4-2、查询边" class="headerlink" title="27.4.2、查询边"></a>27.4.2、查询边</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* 获得边</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* <span class="doctag">@param</span> key 边的key</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* <span class="doctag">@param</span> value 边的value</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* <span class="doctag">@return</span> 边</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Edge <span class="title">GetEdge</span><span class="params">(String key, String value)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    JanusGraph graph = JanusgraphBean.getJanusGraph();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    JanusGraphTransaction transaction = graph.newTransaction();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    GraphTraversalSource g = transaction.traversal();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    Edge e = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    GraphTraversal&lt;?, Edge&gt; graphTraversal = graph.traversal().E().has(key, value);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (graphTraversal.hasNext())&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        e = graphTraversal.next();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> e;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="27-4-3、判断边是否存在"><a href="#27-4-3、判断边是否存在" class="headerlink" title="27.4.3、判断边是否存在"></a>27.4.3、判断边是否存在</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* 判断边是否存在</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* <span class="doctag">@param</span> key 边的key</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* <span class="doctag">@param</span> value 边的value</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* <span class="doctag">@return</span> 是否存在 true:存在 false:不存在</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">edgeIsExist</span><span class="params">(String key, String value)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    JanusGraph graph = JanusgraphBean.getJanusGraph();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    JanusGraphTransaction transaction = graph.newTransaction();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    GraphTraversalSource g = transaction.traversal();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">boolean</span> exist = <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    GraphTraversal&lt;?, Edge&gt; graphTraversal = graph.traversal().E().has(key, value);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (graphTraversal.hasNext()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        exist = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> exist;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="27-4-4、删除节点"><a href="#27-4-4、删除节点" class="headerlink" title="27.4.4、删除节点"></a>27.4.4、删除节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* 删除节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* <span class="doctag">@param</span> graph JanusGraph实例对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* <span class="doctag">@param</span> key 节点的key</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* <span class="doctag">@param</span> value 节点的value</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteVertex</span><span class="params">(JanusGraph graph,String key, String value)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    GraphTraversal&lt;Vertex, Vertex&gt; traversal = graph.traversal().V()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        .has(key, value);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(traversal.hasNext())&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        Vertex thisobj = traversal.next();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        thisobj.remove();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="27-4-5、删除边"><a href="#27-4-5、删除边" class="headerlink" title="27.4.5、删除边"></a>27.4.5、删除边</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* 删除边</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* <span class="doctag">@param</span> graph JanusGraph实例对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* <span class="doctag">@param</span> key 边的key</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">* <span class="doctag">@param</span> value 边的value</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteEdge</span><span class="params">(JanusGraph graph,String key, String value)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    GraphTraversal&lt;Edge, Edge&gt; traversal = graph.traversal().E()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        .has(key, value);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(traversal.hasNext())&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        Edge thisobj = traversal.next();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        thisobj.remove();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="27-4-6、获得节点双向链接所有边的数量"><a href="#27-4-6、获得节点双向链接所有边的数量" class="headerlink" title="27.4.6、获得节点双向链接所有边的数量"></a>27.4.6、获得节点双向链接所有边的数量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 获得节点双向链接所有边的数量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph JanusGraph实例对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 节点的key</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 节点的value</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span> 边的数量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getVertexBothEgdeCount</span><span class="params">(JanusGraph graph,String key, String value)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">long</span> number = <span class="number">0L</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    GraphTraversal&lt;Vertex, Long&gt; traversal = graph.traversal().V()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        .has(key, value)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        .bothE().count();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (traversal.hasNext()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        number = traversal.next();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> number;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="27-4-7、获得节点in方向所有边的数量"><a href="#27-4-7、获得节点in方向所有边的数量" class="headerlink" title="27.4.7、获得节点in方向所有边的数量"></a>27.4.7、获得节点in方向所有边的数量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 获得节点in方向所有边的数量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph JanusGraph实例对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 节点的key</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 节点的value</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span> 节点的数量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getVertexInEgdeCount</span><span class="params">(JanusGraph graph,String key, String value)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">long</span> number = <span class="number">0L</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    GraphTraversal&lt;Vertex, Long&gt; traversal = graph.traversal().V()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        .has(key, value)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        .inE().count();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (traversal.hasNext()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        number = traversal.next();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> number;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="27-4-8、获得节点Out方向所有边的数量"><a href="#27-4-8、获得节点Out方向所有边的数量" class="headerlink" title="27.4.8、获得节点Out方向所有边的数量"></a>27.4.8、获得节点Out方向所有边的数量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 获得节点Out方向所有边的数量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph JanusGraph实例对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 节点的key</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 节点的value</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span> 节点的数量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getVertexOutEgdeCount</span><span class="params">(JanusGraph graph,String key, String value)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">long</span> number = <span class="number">0L</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    GraphTraversal&lt;Vertex, Long&gt; traversal = graph.traversal().V()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        .has(key, value)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        .outE().count();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (traversal.hasNext()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        number = traversal.next();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> number;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="27-4-9、根据边的属性获得节点信息"><a href="#27-4-9、根据边的属性获得节点信息" class="headerlink" title="27.4.9、根据边的属性获得节点信息"></a>27.4.9、根据边的属性获得节点信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 根据边的属性获得节点信息</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph JanusGraph实例对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> ikey 边的index</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 边的value</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span> 节点集合</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Vertex&gt; <span class="title">getVertexByEgdeProperty</span><span class="params">(JanusGraph graph,String ikey, String value)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    List&lt;Vertex&gt; vertexList = graph.traversal().E()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        .has(ikey, value)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        .bothV()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        .dedup()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        .toList();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> vertexList;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="27-4-10、根据边的属性获得边左侧的节点"><a href="#27-4-10、根据边的属性获得边左侧的节点" class="headerlink" title="27.4.10、根据边的属性获得边左侧的节点"></a>27.4.10、根据边的属性获得边左侧的节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 根据边的属性获得边左侧的节点.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph JanusGraph实例对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> ikey 边的index</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 边的value</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span> 边的左侧节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vertex <span class="title">getLeftVertexByEdge</span><span class="params">(JanusGraph graph, String ikey, String value)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    GraphTraversal&lt;Edge, Vertex&gt; traversal = graph.traversal().E()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        .has(ikey, value)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        .outV();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    Vertex v = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (traversal.hasNext())&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        v = traversal.next();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> v;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="27-4-11、根据边的属性获得右侧的节点"><a href="#27-4-11、根据边的属性获得右侧的节点" class="headerlink" title="27.4.11、根据边的属性获得右侧的节点"></a>27.4.11、根据边的属性获得右侧的节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 根据边的属性获得右侧的节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph JanusGraph实例对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> ikey 边的index</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 边的value</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span> 边的右侧节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vertex <span class="title">getRightVertexByEdge</span><span class="params">(JanusGraph graph, String ikey, String value)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    GraphTraversal&lt;Edge, Vertex&gt; traversal = graph.traversal().E()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        .has(ikey, value)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        .inV();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    Vertex v = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (traversal.hasNext())&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        v = traversal.next();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> v;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="27-4-12、获得节点属性的值"><a href="#27-4-12、获得节点属性的值" class="headerlink" title="27.4.12、获得节点属性的值"></a>27.4.12、获得节点属性的值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 获得节点属性的值.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> vmap 节点的属性结合对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 节点的key</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getVertexPropertie</span><span class="params">(Map&lt;String, List&gt; vmap, String key)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    String value = <span class="string">""</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(vmap == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> value;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//是否包含key值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(vmap.containsKey(key))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        List list = vmap.get(key);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(list.size() &gt; <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            value = list.get(<span class="number">0</span>).toString();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> value;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="27-4-13、获得节点属性的值-多态1"><a href="#27-4-13、获得节点属性的值-多态1" class="headerlink" title="27.4.13、获得节点属性的值-多态1"></a>27.4.13、获得节点属性的值-多态1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 获得节点属性的值.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> vmap 节点的属性结合对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 节点的key</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> defaultStr 默认值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getVertexPropertie</span><span class="params">(Map&lt;String, List&gt; vmap, String key,String defaultStr)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    String value = defaultStr;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(vmap == <span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> value;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//是否包含key值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(vmap.containsKey(key))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        List list = vmap.get(key);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(list.size() &gt; <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            Object obj = list.get(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Date)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                Date date = (Date)obj;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span>(date.getTime() != DateUtil.getMinDate().getTime())&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                    value = sdf.format(date);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="string">""</span>.equals(obj))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                value = obj.toString();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> value;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="27-4-14、获得节点属性的值-多态2"><a href="#27-4-14、获得节点属性的值-多态2" class="headerlink" title="27.4.14、获得节点属性的值-多态2"></a>27.4.14、获得节点属性的值-多态2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 获得节点属性的值.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> vmap 节点的属性结合对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 节点的key</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getVertexPropertieObject</span><span class="params">(Map&lt;Object, List&gt; vmap, String key)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    String value = <span class="string">""</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(vmap == <span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> value;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//是否包含key值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(vmap.containsKey(key))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        List list = vmap.get(key);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(list.size() &gt; <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            value = list.get(<span class="number">0</span>).toString();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> value;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>27.4.15、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr></table></figure><p>27.4.16、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr></table></figure><p>27.4.17、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2019年12月5日会议知识分享记录</title>
    <link href="undefined2019/12/09/hello-world/"/>
    <url>2019/12/09/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="一、分享内容题目：图数据库Gremlin"><a href="#一、分享内容题目：图数据库Gremlin" class="headerlink" title="一、分享内容题目：图数据库Gremlin"></a>一、分享内容题目：图数据库Gremlin</h2><h3 id="内容简介："><a href="#内容简介：" class="headerlink" title="内容简介："></a>内容简介：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">1、图数据库的概念以及图数据库的两个重要属性(图存储和图处理引擎)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">2、图数据库与关系型和非关系型数据库进行对比(执行时间，数据模型、优劣势对比)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">3、介绍了Neo4j和JanusGraph两个图数据库</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">4、Cypher和Gremlin图查询语言说明</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">5、图基本概念与基本操作</span></pre></td></tr></table></figure><p>[具体内容]: </p><h3 id="二、分享内容题目：linux环境下的MySQL数据库主从复制"><a href="#二、分享内容题目：linux环境下的MySQL数据库主从复制" class="headerlink" title="二、分享内容题目：linux环境下的MySQL数据库主从复制"></a>二、分享内容题目：linux环境下的MySQL数据库主从复制</h3><p>内容简介：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">1、主从复制原因(防止服务器或数据库出错造成数据丢失或损坏)以及配置虚拟机linux环境</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">2、在linux环境下安装并配置MySQL</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">3、MySQL主从复制配置(注意开启日志服务，通过日志读取数据)</span></pre></td></tr></table></figure><h3 id="三、分享内容题目：爬虫原理及基础"><a href="#三、分享内容题目：爬虫原理及基础" class="headerlink" title="三、分享内容题目：爬虫原理及基础"></a>三、分享内容题目：爬虫原理及基础</h3><p>内容简介：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">1、爬虫原理(请求网站并提取有用数据的自动化程序)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">2、爬虫流程(发起请求、获取并解析内容、保存数据)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">3、Requests请求与Response响应</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">4、解析方式(BeautifulSoup和Xpath解析方式)</span></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>